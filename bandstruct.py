#!/usr/bin/env python
import sys,os,shutil
from math import *
from constants import *

def f_DOS(enk_all,wk_all,width=0.3,nelec=0,nspin=1,de=None,ik_start=None,ik_end=None,emax=None,emin=None,debug=True):
  """
  Calculate density of states at the energy e for given band energies
  """
  ts2 = 2.0*width*width 
  coef = 1.0/(width*sqrt(2.0*Pi))
  nk = len(enk_all) 
  if nspin == 1:
    sfact = 2.0
  else:
    sfact = 1.0 

  if emax == None:     
    emax = -1.0E10
    for ik in range(nk):
      emax = max(emax,max(enk_all[ik]))

    emax += 5.0

  if emin == None:     
    emin = 1.0E10
    for ik in range(nk):
      emin = min(emin,min(enk_all[ik]))

    emin -= 5.0
 
  if ik_start == None: ik_start = 0 
  if ik_end == None:   ik_end = nk
  if de == None:       de = 0.01

  nedos = int((emax - emin) / de  + 1.0 )
  if debug:  
    print " NELEC =",nelec
    print " NEDOS  = ",nedos 
    print " DELTAE = ",de
  
  wk_sum = 0.0 
  for ik in range(nk):
    wk_sum += wk_all[ik]

  dos = []
  for ie in range(nedos):
    e = emin + ie*de 
    d = 0.0 
    for ik in range(nk):
      if ik < ik_start or ik > ik_end: continue  
      wk = wk_all[ik] 
      enk = enk_all[ik]
      nb = len(enk)
      for ib in range(nb):
        en = enk[ib]
        if abs(e-en) < 3*width :
          d = d + wk*coef*exp(-(e-en)**2/ts2 )

    d /= wk_sum 
    dos.append([e,d*sfact]) 

  # calculate Fermi energy if nelec > 0.0
  efer = 0.0 
  if nelec > 0.0: 
    s1 = 0.0
    e1 = 0.0
    for ie in range(nedos):
      s0 = s1; e0 = e1

      e1 = dos[ie][0]
      s1 += dos[ie][1]*de
      if s1 >= nelec and s0 < nelec:  
#        efer = ((nelec-s0)*e1-(nelec-s1)*e0)/(s1-s0)
        efer = e1 
        break 
  return dos,efer 

def f_Write_Eband(out_fn,enk_all,iop_x=0,kvec_all=None):
  """
  Write band energies in the format that can be used for use in xmgrace or GNUplot 
    enk_all: band energies ordered in terms of k-vectors
    iop_x : determine how to set x-axis 
           0 -- integer index for k-vectors 
           1 -- scaled to [0,1]
           2 -- use the cumulative length along the chosen k-path (requires kvec_all) 
  """
  ofile = open(out_fn,'w') 
  nkp = len(enk_all) 
  if nkp <= 1: 
    print "ERROR: nkp<=1!"
    sys.exit(1) 

  nband = len(enk_all[0])
  for ib in range(nband):
    ofile.write("# band %d\n"%(ib+1))

    kx = 0.0 
    for ik in range(nkp):
      if iop_x == 0:
        kx=ik
      elif iop_x == 1:
        kx = ik/(nkp-1)
      ofile.write("%12.6f %12.6f\n"%(kx,enk_all[ik][ib]))
    
    ofile.write("\n")

  ofile.close() 

def f_Read_Eband_flapw(fname,debug=True):
  """
  Read the band energy from the band energy file generated by the flapw code
  """
  ifile = open(fname,'r') 
  
  # the first line 
  line=ifile.readline()
  nkp=0
  kvec_all=[]
  while (1):
    line=ifile.readline()
    if 'k-point list ends' in line: break 
    s_line = line.split()
    kvec=[]
    for i in range(3):
      kvec.append(float(s_line[i]))

    nkp += 1
    kvec_all.append(kvec)

  line=ifile.readline() # blank line 
  line=ifile.readline() # "band energies start"
  line=ifile.readline() # "spin = 1"

  enk_all=[]
  for ik in range(nkp):
    line = ifile.readline()
    s_line = line.split() 
    enk = []
    for n in range(len(s_line)):
      enk.append(float(s_line[n]))
    enk_all.append(enk)
  
  ifile.close()
  return enk_all,kvec_all

def f_Read_Eband_w2k(fname,debug=True):
  """
  Read band energies in the wien2k case.energy format 
  """
  print "Read band energies from " + fname
  ifile = open(fname,'r')

  # skip the head, determine the end of the head in terms of the length of the line 
  nl_head = 0 
  while (1):
    line= ifile.readline()
    if(len(line) < 100): break  
    nl_head += 1 

  nl_head 
  if debug: 
    print "the number of lines for the head part (check whether equal to nat*2!): ",nl_head 
  
  ik=0
  enk_all = []
  kw_all = []
  kv_all = []
  while 1:
    ik += 1
    # k-vectors, number of bands at each k, and the weight of this k     
    kv = [ float(line[0:19]), float(line[19:38]), float(line[38:57]) ]
    nbk = int(line[73:79])
    kw =  float(line[79:84])

    if debug:
      print "Read the band energy for ik=%5d,k=(%8.4f, %8.4f, %8.4f), nbk=%5d, wk=%5.1f"%(ik,kv[0],kv[1],kv[2],nbk,kw)
      print "%5s %12s"%("n","Enk")

    enk = []
    for ie in range(nbk):
      s_en = ifile.readline().split()
      n = int(s_en[0])
      en = float(s_en[1])
      enk.append(en)
      if debug: print "%5d %12.6f"%(n,en)

    kv_all.append(kv)
    kw_all.append(kw)
    enk_all.append(enk)

    line = ifile.readline()
    if not line: break # end of file readed 

  ifile.close()
  return enk_all,kv_all,kw_all

#!/usr/bin/env python
from constants import *

def band_gap_analysis(enk,efer,kvec,title="Gap Analysis",unit='eV',emin=-10,emax=+5,ib0=1,debug=False):

  if unit == 'eV':
    u2eV = 1.0 
  elif unit == 'Ry':
    u2eV = Ry2eV
  elif unit == 'Ha':
    u2eV = 2.0*Ry2eV

  if emin == None: 
    if unit == 'eV': emin = -27.0
    if unit == 'Ha': emin = -1.0 
    if unit == 'Ry': emin = -2.0

  if emax == None:
    if unit == 'eV': emax = 27.2
    if unit == 'Ha': emax = 1.0
    if unit == 'Ry': emax = 2.0

  nsp = len(enk)
  nk  = len(kvec)
  nband = len(enk[0][0])

  nt = (80-len(title))/2
  print "!"+'-'*80+"!"
  print '!'+' '*nt+title+' '*nt+"!"
  print "!"+'-'*80+"!"
  
  print "\tNumber of spin =      %5d"%(nsp)
  print "\tNumber of k-vector = %5d"%(nk)
  print "\tNumber of bands =    %5d"%(nband)

  nomax = []
  numin = []
  ikvm =  []
  ikcm =  []

  lmetal = False
  for isp in range(nsp):
    nomax.append(0)
    numin.append(nband)
    ikvm.append(0)
    ikcm.append(0)
    for ik in range(nk):
      nbk = len(enk[isp][ik])

      if debug:
        print "  %5d bands for ik=%5d"%(nbk,ik)

      if nbk < nband: nband = nbk
      nv = 0
      nc = nbk-1
      for ib in range(nbk):
        if enk[isp][ik][ib] <= efer + 0.00001:
          if ib > nv: nv = ib
        else:
          if ib < nc: nc = ib
      if nv > nomax[isp]:  nomax[isp] = nv
      if nc < numin[isp]:  numin[isp] = nc

      nv  = nomax[isp]
      nc  = numin[isp]
      ikv = ikvm[isp]
      ikc = ikcm[isp]
      if enk[isp][ik][nv] > enk[isp][ikv][nv]: ikvm[isp] = ik
      if enk[isp][ik][nc] < enk[isp][ikc][nc]: ikcm[isp] = ik
    # loop over ik

    if nomax[isp] >= numin[isp]: lmetal = True

  # end loop over isp

  # set evbm, which is used as the energy zero 
  if lmetal :
    evbm = efer
  else:
    if nsp==1:
      evbm = enk[0][ikvm[0]][nomax[0]]
    else:
      evbm = max( enk[0][ikvm[0]][nomax[0]], enk[1][ikvm[1]][nomax[1]] )

  for isp in range(nsp):
    nv = nomax[isp]
    nc = numin[isp]
    ikv = ikvm[isp]
    ikc = ikcm[isp]
    if nsp ==2: print "\nBand analysis for spin",isp
    print "Band index for VBM and CBM=",nv+ib0,nc+ib0

    if not lmetal:
      print "Insulating system:"
      egap = (enk[isp][ikc][nc] - enk[isp][ikv][nv])*u2eV
      if ikvm[isp] == ikcm[isp]:
        print ":BandGap(d) =%8.3f eV "%(egap)
        print "  direct gap at k=(%8.3f,%8.3f,%8.3f)"%(kvec[ikv][0],kvec[ikv][1],kvec[ikv][2])
      else:
        print ":BandGap(i) =%8.3f eV "%(egap)
        egvbm = (enk[isp][ikv][nc] - enk[isp][ikv][nv] )*u2eV
        egcbm = (enk[isp][ikc][nc] - enk[isp][ikc][nv] )*u2eV

        egm = (enk[isp][0][nc] - enk[isp][0][nv])*u2eV
        ikm = 0
        for ik in range(nk):
          egk = (enk[isp][ik][nc] - enk[isp][ik][nv])*u2eV
          if egk < egm:
            egm = egk
            ikm = ik
        print ":Eg_d(min) =%8.3f eV, at      k=(%8.3f,%8.3f,%8.3f) (ik=%4d)"%(egm,  kvec[ikm][0], kvec[ikm][1], kvec[ikm][2],ikm+1)
        print ":Eg_direct =%8.3f eV  at  VBM k=(%8.3f,%8.3f,%8.3f) (ik=%4d)"%(egvbm,kvec[ikv][0], kvec[ikv][1], kvec[ikv][2],ikv+1)
        print ":Eg_direct =%8.3f eV  at  CBM k=(%8.3f,%8.3f,%8.3f) (ik=%4d)"%(egcbm,kvec[ikc][0], kvec[ikc][1], kvec[ikc][2],ikc+1)
    else:
      egap = 0.0 
      print "Metallic system"

    print "Range of each band with respect to VBM (eV):"
    print "%5s%12s%12s%12s"%('n','Bottom','Top','Width')
    for ib in range(nband):
      ebmin=enk[isp][0][ib]
      ebmax=enk[isp][0][ib]

      for ik in range(nk):
        if enk[isp][ik][ib] < ebmin:
          ebmin = enk[isp][ik][ib]
        if enk[isp][ik][ib] > ebmax:
          ebmax = enk[isp][ik][ib]

      ebmin *= u2eV
      ebmax *= u2eV

#      ebmin = ebmin - evbm
#      ebmax = ebmax - evbm
      if ebmin > evbm + emin  and ebmax <  egap + evbm + emax:
        print "%5d%12.3f%12.3f%12.3f"%(ib+ib0,ebmin,ebmax,(ebmax-ebmin)*u2eV)
    # end loop over ib
  # end loop over isp 

  return egap

