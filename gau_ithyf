#!/usr/bin/env python
from io_utils import *
from struct_utils import *
from gau_utils    import *
from constants import *
from list_utils import *
from numpy import *


def f_Help_Info():
  myname = sys.argv[0]
  print "\n"+myname + ": a Python script to run Ionization-potential Tuned Hybrid Functional (IT-HYF) calculation \n"
  print "   Usage: " + os.path.basename(myname) + " [options]"\
  + """
  Options:  
    --debug              # set debug mode
    -h                   # display this help information 
    -b  <basis>          # basis used for the calculation
    -cm0 <ch_0 mult_0>   # charge and multiplicity for the "neutral" case 
    -cm1 <ch_1 mult_1>   # charge and multiplicity for the IP case
    -cm2 <ch_2 mult_2>   # charge and multiplicity for the EA case 
    -f  <file >          # the prefix for files generated by this script   
    -hfx <hfx>           # the fraction of the Hartree-Fock exchange
    -i  <inp>            # the <inp> file contains the molecular structure whose format 
                           is indicated by this suffix, currently it supports 
                           xyz, gjf, mol or log/out (G09 optimzation output)  
    -m   <mode=0>          #  0 -- use IP only
                         #  1 -- use both IP and EA 
    -n   <nhfx=5>          # the number of hfx's to be calculated 
                         # the default is 5, and hfx = ( 0.0, 0.25, 0.50, 0.75, 1.0 ) 

    -np  <nproc=4>       # set the directive for parallelization 
    
    -o   <opt=''>          # additional option for SCF calculations       
    -sp  <up/dn>         
    -t   <task=1>          # which task 
                         #  0 -- generate input file(s) onlythe  
                         #  1 -- generate input files, run the calculation and summarize the final results 
                         #  2 -- summarize results only 
    -td                  # perform a TD calculation afterwards using the optimized hfx 
    -tdopt <tdopt>       # set TD option 
    -tdbas <tdbas>       # set the basis used for TD calculation 
    -xc  <xc>            # which hybrid functional to be tuned (PBE0/B3LYP/B1LYP)
"""
  sys.exit(0)

def_basis = "6-31G*"
def_file = ''
def_debug = False
def_opt = ""
def_nproc = 4
def_inp = ''
def_xc  = 'B1LYP'
def_hfx = [0.0, 0.25, 0.50, 0.75, 1.0] 
def_nhfx = 5
def_task = 1 
def_mode = 0 
def_cm0  =  [0, 1] 
def_cm1  =  [1, 2]
def_cm2  = [-1, 2]
def_sp   = 'up'
def_td = False 
def_tdopt = " TD(50-50,NStates=5) "

if f_Getopt('-h',0,False): f_Help_Info()
debug  = f_Getopt('--debug', 0, def_debug ) 

basis  = f_Getopt('-b'     , 1, def_basis )      
file   = f_Getopt('-f'     , 1, def_file  )
cm0    = f_Getopt('-cm0'   , 2, def_cm0   )
cm1    = f_Getopt('-cm1'   , 2, def_cm1   )
cm2    = f_Getopt('-cm2'   , 2, def_cm2   )
inp    = f_Getopt('-i'     , 1, def_inp   ) 
mode   = f_Getopt('-m'     , 1, def_mode  ) 
nproc  = f_Getopt('-np'    , 1, def_nproc ) 
opt    = f_Getopt('-o'     , 1, def_opt   ) 
spin   = f_Getopt('-sp'    , 1, def_sp    )
task   = f_Getopt('-t'     , 1, def_task  ) 
td     = f_Getopt('-td'    , 0, def_td    ) 
tdopt  = f_Getopt('-tdopt' , 1, def_tdopt )
tdbas  = f_Getopt('-tdbas' , 1, basis     ) 
xc     = f_Getopt('-xc'    , 1, def_xc    ) 

nhfx   = f_Getopt('-n'     , 1, def_nhfx ) 
hfx    = f_Getopt('-hfx'   , nhfx, def_hfx   ) 

if debug:  print "nhfx,hfx=",nhfx,hfx 

# get the initial structure if "-i <inp>" is present 
if inp != '':
  inp_sfix = os.path.splitext(inp)[-1][1:]
  inp_pfix = os.path.splitext(inp)[0] 

  print "*** get initial structure from " + inp  + " ***"
  if inp_sfix == 'gjf': 
    mol = f_Gau_read_struct_gjf(inp_pfix)
  elif inp_sfix == 'xyz':
    mol = f_Read_Struct_xyz(inp_pfix,debug=debug)
  elif inp_sfix == 'mol':
    mol = f_Read_Struct_mol(inp_pfix,debug=debug)
  elif inp_sfix == 'log' or inp_sfix == 'out':
    mol = f_Gau_Read_Struct(inp, debug=debug) 
  else:
    print "error: unsupported format in the input file " + inp 
    sys.exit(1)
  if file == '': file = inp_pfix+"-"+xc

results = [] 

g09_chk = file+".chk"

for icase in range(nhfx):
  hfx_i = hfx[icase] 
  if nhfx == 1: 
    g09_inp = file+".gjf"
    g09_out = file+".log" 
  else:
    g09_inp = file + "-x%4.2f"%(hfx_i) + ".gjf"
    g09_out = file + "-x%4.2f"%(hfx_i) + ".log" 

  print "\n case %d, hfx=%6.3f"%(icase,hfx_i)

  # prepare the input files 
  if task <= 1: 
    print "*** create G09 input file" + g09_inp  + " ***"

    ofile = open(g09_inp,'w') 

    ofile.write("%chk="+g09_chk+"\n")
    if nproc > 0 : ofile.write('%nprocshared='+"%d\n"%(nproc))
    method = f_Gau_set_hybrid(xc,basis,hfx_i) + opt 

    ofile.write("# " + method + " test\n\n")
    ofile.write("SCF calculation in the neutral state\n\n")
    ofile.write("%3d %3d\n"%(cm0[0],cm0[1]))
    for ia in range(len(mol)):
      atom = mol[ia][0]
      xyz = mol[ia][1]
      ofile.write("%-6s %12.6f %12.6f %12.6f\n"%(atom,xyz[0],xyz[1],xyz[2]))

    ofile.write("\n--Link1--\n")
    ofile.write("%chk="+g09_chk+"\n")
    if nproc > 0 : ofile.write('%nprocshared='+"%d\n"%(nproc))
    ofile.write("# U" + method + " geom=checkpoint test \n\n")
    ofile.write("SCF calculation of the postively charged state \n\n")
    ofile.write("%3d %3d\n"%(cm1[0],cm1[1]))

    if mode == 1: 
      ofile.write("--Link1--\n")
      ofile.write("%chk="+g09_chk+"\n")
      if nproc > 0 : ofile.write('%nprocshared='+"%d\n"%(nproc))
      ofile.write("# U" + method + " geom=checkpoint test \n\n")
      ofile.write("SCF calculation of the negatively charged state \n\n")
      ofile.write("%3d %3d\n"%(cm2[0],cm2[1]))

    ofile.close()
     
  if task == 0: sys.exit(0) 

  if task == 1: 
    if debug: print "\n*** run G09 ***"
    f_Gau_run_g09(g09_inp,g09_out) 

  etot = f_Gau_read_energy(g09_out)
  if mode ==0 : 
    print "Etot(N)=%12.6f Ha, Etot(N-1)=%12.6f Ha"%(etot[0],etot[1])
  else:
    print "Etot(N)=%12.6f Ha, Etot(N-1)=%12.6f Ha, Etot(N+1)= %12.6f Ha"%(etot[0],etot[1],etot[2]) 

  IP = (etot[1]-etot[0])*Ha2eV

  data = f_Gau_read_egap(g09_out,spin,debug=debug)
  egap = data[0][0]*Ha2eV
  ehomo = data[0][1]*Ha2eV
  
  if mode == 1:  
    EA = (etot[0] - etot[2])*Ha2eV 
    ehomo_m = data[2][1]*Ha2eV
    
    results.append([hfx_i,IP,ehomo,egap, EA, ehomo_m]) 
  else:
    results.append([hfx_i,IP,ehomo,egap])

print "\n---------- Summary ------------"  
ofile = open(file+"-results.dat",'w')
ofile.write("#Summary of the IT-HYF calcuation using the hybrid functional "+ xc + " with the basis " + basis + "\n") 
if mode == 0: 
  info="#%7s %8s %8s %8s %8s %8s   (all in eV)"%("HF_x","eHO","e_LU","egap","IP","eHO+IP")
else:
  info="#%7s %8s %8s %8s %8s %8s %8s %8s  (all in eV)"%("HF_x","eHO","e_LU","egap", "IP", "eHO+IP","EA","eHO(N+1)")

print info 
ofile.write(info+"\n")

x_fit = []
fx_fit = [[],[],[]]
for i in range(nhfx):
  hfx_i = results[i][0]
  IP = results[i][1]
  ehomo = results[i][2]
  egap = results[i][3]
  elumo = ehomo + egap

  x_fit.append(hfx_i)
  fx_fit[0].append(ehomo+IP)
  fx_fit[1].append(ehomo)
  fx_fit[2].append(egap) 
  
  if mode == 0: 
    info="%8.3f %8.3f %8.3f %8.3f %8.3f %8.3f"%(hfx_i,ehomo,elumo,egap,IP,ehomo+IP)
  else:
    EA = results[i][4]
    ehomo_m = results[i][5]
    info="%8.3f %8.3f %8.3f %8.3f %8.3f %8.3f %8.3f %8.3f"%(hfx_i,ehomo,elumo,egap,IP, ehomo+IP, EA, ehomo_m)

  print info 
  ofile.write(info+"\n")

coef = polyfit(x_fit,fx_fit[0],1)
hfx_opt = -coef[1]/coef[0]

coef = polyfit(x_fit,fx_fit[1],1) 
ehomo_opt = coef[0]*hfx_opt+ coef[1]

coef = polyfit(x_fit,fx_fit[2],1)
egap_opt = coef[0]*hfx_opt+ coef[1]

info="#Tuned hfx=%8.3f ==> ehomo=%8.3f eV, egap=%8.3f eV"%(hfx_opt,ehomo_opt, egap_opt)
print info
ofile.write(info+"\n")
ofile.close()

if td:  # perform a TDDFT calculation using the optimized hfx 
  print "\n*** Perform TDDFT calculation using optimized hfx ***"
  g09_inp = file+"s-td.gjf"
  g09_out = file+"s-td.log"    
  ofile = open(g09_inp,'w')
  ofile.write("%chk="+g09_chk+"\n")
  if nproc > 0 : ofile.write('%nprocshared='+"%d\n"%(nproc))
  method = f_Gau_set_hybrid(xc,tdbas,hfx_opt) + ' ' + opt + ' ' +  tdopt
  ofile.write("# " + method + " test\n\n")
  ofile.write("TDDFT calculation using the optimized hfx \n\n")
  ofile.write("0 1\n")
  for ia in range(len(mol)):
    atom = mol[ia][0]
    xyz = mol[ia][1]
    ofile.write("%-6s %12.6f %12.6f %12.6f\n"%(atom,xyz[0],xyz[1],xyz[2]))

  ofile.write("\n")
  ofile.close() 
  f_Gau_run_g09(g09_inp,g09_out)
  
