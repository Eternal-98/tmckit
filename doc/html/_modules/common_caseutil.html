<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>common_caseutil &mdash; TMCkit 0.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/agogo.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="TMCkit 0.1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" /> 
  </head>
  <body role="document">
    <div class="header-wrapper" role="banner">
      <div class="header">
        <div class="headertitle"><a
          href="../index.html">TMCkit 0.1 documentation</a></div>
        <div class="rel" role="navigation" aria-label="related navigation">
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a>
        </div>
       </div>
    </div>

    <div class="content-wrapper">
      <div class="content">
        <div class="document">
            
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for common_caseutil</h1><div class="highlight"><pre>
<span class="c">#!/usr/bin/env python</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span><span class="nn">os</span><span class="o">,</span><span class="nn">commands</span><span class="o">,</span><span class="nn">subprocess</span><span class="o">,</span><span class="nn">copy</span><span class="o">,</span><span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="c">#import numpy,numpy.linalg</span>
<span class="kn">import</span> <span class="nn">constants</span>

<span class="kn">import</span> <span class="nn">list_utils</span> <span class="kn">as</span> <span class="nn">lu</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">kpt_spec</span>

<span class="kn">from</span> <span class="nn">py_xmlio</span> <span class="kn">import</span> <span class="n">XMLSerilizer</span>

<span class="n">logLevel</span> <span class="o">=</span> <span class="mi">0</span>

<div class="viewcode-block" id="deprecated"><a class="viewcode-back" href="../main_struct.html#common_caseutil.deprecated">[docs]</a><span class="k">def</span> <span class="nf">deprecated</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This is a decorator which can be used to mark functions</span>
<span class="sd">    as deprecated. It will result in a warning being emitted</span>
<span class="sd">    when the function is used.&quot;&quot;&quot;</span>
    
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">new_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn_explicit</span><span class="p">(</span>
            <span class="s">&quot;Call to deprecated function </span><span class="si">%(funcname)s</span><span class="s">.&quot;</span> <span class="o">%</span> <span class="p">{</span>
                <span class="s">&#39;funcname&#39;</span><span class="p">:</span> <span class="n">func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">category</span><span class="o">=</span><span class="ne">DeprecationWarning</span><span class="p">,</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_filename</span><span class="p">,</span>
            <span class="n">lineno</span><span class="o">=</span><span class="n">func</span><span class="o">.</span><span class="n">func_code</span><span class="o">.</span><span class="n">co_firstlineno</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_func</span>

  </div>
<div class="viewcode-block" id="debug_print"><a class="viewcode-back" href="../main_struct.html#common_caseutil.debug_print">[docs]</a><span class="k">def</span> <span class="nf">debug_print</span><span class="p">(</span><span class="n">level</span><span class="p">,</span><span class="o">*</span><span class="n">para</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    print for debug, logLevel can be used to control whether output</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">level</span> <span class="o">&lt;=</span> <span class="n">logLevel</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">para</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">end</span><span class="o">=</span><span class="s">&quot; &quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="FormatError"><a class="viewcode-back" href="../main_struct.html#common_caseutil.FormatError">[docs]</a><span class="k">class</span> <span class="nc">FormatError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Represent file format incorrect</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>
</div>
<div class="viewcode-block" id="f_ReadFileFloatValue"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_ReadFileFloatValue">[docs]</a><span class="k">def</span> <span class="nf">f_ReadFileFloatValue</span><span class="p">(</span><span class="n">stFileName</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read a single floating point value of one file</span>
<span class="sd">    If the file does not exists, then return None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)):</span>
        <span class="n">fIn</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span>  <span class="nb">float</span><span class="p">(</span><span class="n">fIn</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="n">fIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">d</span>  
</div>
<div class="viewcode-block" id="f_ReadFileIntValue"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_ReadFileIntValue">[docs]</a><span class="k">def</span> <span class="nf">f_ReadFileIntValue</span><span class="p">(</span><span class="n">stFileName</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read a single integer point value of one file</span>
<span class="sd">    If the file does not exists, then return None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)):</span>
        <span class="n">fIn</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span>  <span class="nb">int</span><span class="p">(</span><span class="n">fIn</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="n">fIn</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">d</span>  
    </div>
<div class="viewcode-block" id="f_WriteFileFloatValue"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_WriteFileFloatValue">[docs]</a><span class="k">def</span> <span class="nf">f_WriteFileFloatValue</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write a single floating point value to one file</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="f_WriteFileIntValue"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_WriteFileIntValue">[docs]</a><span class="k">def</span> <span class="nf">f_WriteFileIntValue</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write a single integer value to one file</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="f_write_file_string"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_write_file_string">[docs]</a><span class="k">def</span> <span class="nf">f_write_file_string</span><span class="p">(</span><span class="n">val</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write a single string to one file</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="f_FindGCD"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_FindGCD">[docs]</a><span class="k">def</span> <span class="nf">f_FindGCD</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the greatest common divisor of two integers</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">n2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">n1</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">n1</span> <span class="o">&gt;</span> <span class="n">n2</span> <span class="p">):</span>
        <span class="k">return</span> <span class="n">f_FindGCD</span><span class="p">(</span><span class="n">n2</span><span class="p">,</span><span class="n">n1</span> <span class="o">%</span> <span class="n">n2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f_FindGCD</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="o">%</span> <span class="n">n1</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="f_FindLCM"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_FindLCM">[docs]</a><span class="k">def</span> <span class="nf">f_FindLCM</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the least common multiple of two integers</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">n1</span><span class="o">*</span><span class="n">n2</span><span class="o">/</span><span class="n">f_FindGCD</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="f_FindFraction"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_FindFraction">[docs]</a><span class="k">def</span> <span class="nf">f_FindFraction</span><span class="p">(</span><span class="n">dIn</span><span class="p">,</span><span class="n">dErrMax</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">,</span><span class="n">dMaxDiv</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the most appraoching fraction for given float number</span>

<span class="sd">    :param dIn: the floating number</span>
<span class="sd">    :param dErrMax: the relative maximum error allowed between fraction and dIn</span>
<span class="sd">    :param dMaxDiv: the maximum divider allowed</span>
<span class="sd">    :return: two integer to represent the fraction. If not found, return two None</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">dMaxDiv</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">d2</span><span class="o">=</span>  <span class="n">dIn</span><span class="o">*</span><span class="n">i</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">d2</span><span class="o">-</span><span class="nb">round</span><span class="p">(</span><span class="n">d2</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">dErrMax</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">dIn</span><span class="o">*</span><span class="n">i</span><span class="p">)),</span><span class="n">i</span>

    <span class="k">return</span> <span class="bp">None</span><span class="p">,</span><span class="bp">None</span>
</div>
<div class="viewcode-block" id="f_CorrectFloat"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_CorrectFloat">[docs]</a><span class="k">def</span> <span class="nf">f_CorrectFloat</span><span class="p">(</span><span class="n">dIn</span><span class="p">,</span><span class="n">dErrMax</span><span class="o">=</span><span class="mf">1.0e-6</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    make a float number reach the most exact value ( like 60.00000001 to 60 )</span>
<span class="sd">    also make it reach 1/6, 1/5, 1/4 , 1/3 1/2 and so on</span>

<span class="sd">    :param dIn: The number to be detect and modify, or an array ( every number in it will be modified)</span>
<span class="sd">    :param dErrMax: The error can be treated as floating point error</span>
<span class="sd">    :return: 0 if not found, otherwise x in 1/x </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">Correct</span><span class="p">(</span><span class="n">dOld</span><span class="p">,</span><span class="n">dErrMax</span><span class="p">):</span>
        <span class="n">d2</span> <span class="o">=</span> <span class="n">dOld</span>
        <span class="n">bOK</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">nMax10</span> <span class="o">=</span> <span class="mi">2</span> <span class="c">#  integer from 1-10^nMax10 as divide</span>
        <span class="k">for</span> <span class="n">j2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nMax10</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j1</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">j1</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**</span><span class="n">j2</span>
                <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dOld</span><span class="o">*</span><span class="n">j</span> <span class="o">-</span> <span class="nb">round</span><span class="p">(</span><span class="n">dOld</span><span class="o">*</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span> <span class="p">)</span> <span class="o">&lt;</span> <span class="n">dErrMax</span><span class="o">*</span><span class="n">j</span><span class="p">):</span>
                    <span class="c">#print(&quot;Correct with %7i : %20.14f to %20.14f&quot;%(j,result,round(dOld*j)/j))</span>
                    <span class="n">d2</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">dOld</span><span class="o">*</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="n">j</span>
                    <span class="n">bOK</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bOK</span> <span class="p">):</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">d2</span>


    <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">dIn</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="nb">list</span><span class="p">)</span> <span class="p">):</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">Correct</span><span class="p">(</span><span class="n">dIn</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">dErrMax</span><span class="p">)</span>
           <span class="c">#d1 = dIn[j]</span>
           <span class="c">#for i1 in range (1,10):</span>
           <span class="c">#    for i2 in range (0,7):</span>
           <span class="c">#        i = i1 * 10**i2</span>
           <span class="c">#        if ( abs(d1*i - round(d1*i,0) ) &lt; dErrMax*i):</span>
           <span class="c">#            result[j] = round(d1*i)/i</span>
           <span class="c">#            break</span>
    <span class="k">elif</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">Correct</span><span class="p">(</span><span class="n">dIn</span><span class="p">,</span><span class="n">dErrMax</span><span class="p">)</span>
       <span class="c">#for i1 in range (1,10):</span>
       <span class="c">#    for i2 in range(0,7):</span>
       <span class="c">#        i = i1 * 10**i2</span>
       <span class="c">#        if ( abs(dIn*i - round(dIn*i,0) ) &lt; dErrMax*i):</span>
       <span class="c">#            #print(&quot;Correct %20.14f to %20.14f&quot;%(result,round(dIn*i)/i))</span>
       <span class="c">#            result = round(dIn*i)/i</span>
       <span class="c">#            break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">,</span><span class="s">&#39;Unsupported type to correct&#39;</span>
        
    <span class="k">return</span> <span class="n">result</span>
            </div>
<div class="viewcode-block" id="f_File_IsNullOrEmpty"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_File_IsNullOrEmpty">[docs]</a><span class="k">def</span> <span class="nf">f_File_IsNullOrEmpty</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine whether a file does not exist, or is empty</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">stat</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">st_size</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span> 
    <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="f_GetLibDataPath"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_GetLibDataPath">[docs]</a><span class="k">def</span> <span class="nf">f_GetLibDataPath</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get PYTHONPATH for read some data file in the path</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

</div>
<div class="viewcode-block" id="f_GetExecFullPath"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_GetExecFullPath">[docs]</a><span class="k">def</span> <span class="nf">f_GetExecFullPath</span><span class="p">(</span><span class="n">stExe</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get a program full path</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">status</span><span class="p">,</span><span class="n">stOut</span><span class="o">=</span> <span class="n">commands</span><span class="o">.</span><span class="n">getstatusoutput</span><span class="p">(</span><span class="s">&quot;which &quot;</span><span class="o">+</span><span class="n">stExe</span><span class="p">)</span>
    <span class="n">stHome</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getenv</span><span class="p">(</span><span class="s">&quot;HOME&quot;</span><span class="p">)</span>
    <span class="c">#replace home folder</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">stOut</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;~&quot;</span><span class="p">):</span>
        <span class="n">stOut</span> <span class="o">=</span> <span class="n">stHome</span><span class="o">+</span><span class="n">stOut</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">stOut</span>
</div>
<div class="viewcode-block" id="f_File_GetLibraryPath"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_File_GetLibraryPath">[docs]</a><span class="k">def</span> <span class="nf">f_File_GetLibraryPath</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the path of python library file itself</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="f_file_ensuredir"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_file_ensuredir">[docs]</a><span class="k">def</span> <span class="nf">f_file_ensuredir</span><span class="p">(</span><span class="n">dirname</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Test whether a directory exists. If not then create it.</span>

<span class="sd">    :param dirname: the directory to create. If it is empty or None, then set to current directory</span>
<span class="sd">    :return: the diretory path guaranteed to work</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dirname</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">dirname</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="n">dirname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
    <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">dirname</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">dirname</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dirname</span>
</div>
<div class="viewcode-block" id="f_file_ensure_no_file"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_file_ensure_no_file">[docs]</a><span class="k">def</span> <span class="nf">f_file_ensure_no_file</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Test whether a file  exists. If yes then delete it.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">filename</span><span class="p">)):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="f_ReadStdout"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_ReadStdout">[docs]</a><span class="k">def</span> <span class="nf">f_ReadStdout</span><span class="p">(</span><span class="n">cmd</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Open a Shell with specific command and return its stdout </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">ProcSub</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">cmd</span><span class="p">,</span><span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span><span class="n">shell</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ProcSub</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="f_env_GetJobSystem"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_env_GetJobSystem">[docs]</a><span class="k">def</span> <span class="nf">f_env_GetJobSystem</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get Job Management System Name</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;LSF_VERSION&quot;</span><span class="p">)</span> <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;LSF&quot;</span>
    <span class="k">elif</span> <span class="p">(</span> <span class="s">&quot;pbs&quot;</span> <span class="ow">in</span> <span class="n">commands</span><span class="o">.</span><span class="n">getoutput</span><span class="p">(</span><span class="s">&quot;which qsub&quot;</span><span class="p">)</span>  <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;PBS&quot;</span>
        
    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="f_env_MpirunCommand"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_env_MpirunCommand">[docs]</a><span class="k">def</span> <span class="nf">f_env_MpirunCommand</span><span class="p">(</span><span class="n">stCommand</span><span class="p">,</span><span class="n">nProcessIn</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">stJobSystem</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    create a string to run command with mpirun</span>
<span class="sd">    if enviroment varialbe tmckit_serial = 1, then mpirun will not be used ( depreceted )</span>
<span class="sd">    if nProcess = 0 and enviroment varialbe tmckit_process is set, then use $tmckit_process as nProcess will be used</span>

<span class="sd">    :param stCommand: The main command used after mpirun</span>
<span class="sd">    :param nProcess: The count of process. If not used or set as 0, default to hostfile</span>
<span class="sd">    :param stJobSystem: Specify Job Management System. If not used, default as auto detect. If no job system detected, the command will be used directly.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">nProcess</span> <span class="o">=</span> <span class="n">nProcessIn</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">nProcess</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;tmckit_process&quot;</span><span class="p">)):</span>
        <span class="n">nProcess</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s">&quot;tmckit_process&quot;</span><span class="p">])</span>
         
    <span class="k">if</span> <span class="p">(</span> <span class="n">nProcess</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nProcess</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">stRun</span> <span class="o">=</span> <span class="s">&quot;mpirun -np </span><span class="si">%d</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nProcess</span><span class="p">,</span><span class="n">stCommand</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stRun</span> <span class="o">=</span> <span class="n">stCommand</span>
    <span class="k">else</span><span class="p">:</span>        
        <span class="n">dicJob</span> <span class="o">=</span> <span class="p">{</span><span class="s">&quot;PBS&quot;</span><span class="p">:</span><span class="s">&quot;PBS_NODEFILE&quot;</span><span class="p">,</span><span class="s">&quot;LSF&quot;</span><span class="p">:</span><span class="s">&quot;LSF_MCPU_HOSTS&quot;</span><span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stJobSystem</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">stJobSystem</span> <span class="o">=</span> <span class="n">f_env_GetJobSystem</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stJobSystem</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">stRun</span> <span class="o">=</span> <span class="s">&quot;mpirun -hostfile </span><span class="si">%s</span><span class="s"> </span><span class="si">%s</span><span class="s">&quot;</span><span class="o">%</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="n">dicJob</span><span class="p">[</span><span class="n">stJobSystem</span><span class="p">]],</span><span class="n">stCommand</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stRun</span> <span class="o">=</span> <span class="n">stCommand</span>
            
    <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\33</span><span class="s">[34mCommand:</span><span class="se">\33</span><span class="s">[m</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span><span class="n">stRun</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">stRun</span>   
</div>
<div class="viewcode-block" id="f_env_RunMpirunCommand"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_env_RunMpirunCommand">[docs]</a><span class="k">def</span> <span class="nf">f_env_RunMpirunCommand</span><span class="p">(</span><span class="n">stCommand</span><span class="p">,</span><span class="n">nProcess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span><span class="n">stJobSystem</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    run command with mpirun</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">status</span><span class="p">,</span><span class="n">stStdOut</span> <span class="o">=</span> <span class="n">commands</span><span class="o">.</span><span class="n">getstatusoutput</span><span class="p">(</span><span class="n">f_env_MpirunCommand</span><span class="p">(</span><span class="n">stCommand</span><span class="p">,</span><span class="n">nProcess</span><span class="p">,</span><span class="n">stJobSystem</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">status</span><span class="p">,</span><span class="n">stStdOut</span>    
</div>
<div class="viewcode-block" id="f_GetCaseName"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_GetCaseName">[docs]</a><span class="k">def</span> <span class="nf">f_GetCaseName</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get current folder name, used in Wien2K as casename</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">())</span>



</div>
<div class="viewcode-block" id="GetDefaultCharge"><a class="viewcode-back" href="../main_struct.html#common_caseutil.GetDefaultCharge">[docs]</a><span class="k">def</span> <span class="nf">GetDefaultCharge</span><span class="p">(</span><span class="n">nIndex</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Give a default Charge for specific atom index</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        
    <span class="n">nT</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">listAdd</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">18</span><span class="p">,</span><span class="mi">32</span><span class="p">,</span><span class="mi">32</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">nRow</span><span class="p">,</span><span class="n">nAdd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listAdd</span><span class="p">):</span>
        <span class="n">nT</span> <span class="o">=</span> <span class="n">nT</span><span class="o">+</span><span class="n">nAdd</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nT</span> <span class="o">&gt;=</span> <span class="n">nIndex</span><span class="p">):</span>
            <span class="n">nLeft</span> <span class="o">=</span> <span class="n">nIndex</span> <span class="o">-</span> <span class="n">nT</span> <span class="o">+</span><span class="n">nAdd</span>
            <span class="n">nRight</span> <span class="o">=</span> <span class="n">nT</span><span class="o">-</span><span class="n">nIndex</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nT</span> <span class="o">==</span> <span class="n">nIndex</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span> <span class="c"># rare gas</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">nLeft</span> <span class="o">&lt;=</span> <span class="mi">3</span> <span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">nLeft</span> <span class="c"># IA-IIIA,IIIB</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">nRight</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">nRight</span><span class="o">+</span><span class="n">nRow</span> <span class="o">&lt;=</span><span class="mi">5</span> <span class="p">):</span> <span class="c">#Diagnoal split</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">nRight</span> <span class="c"># - IIIA-VIIA</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="mi">8</span> <span class="o">-</span><span class="n">nRight</span> <span class="c"># + ,IB-IIB IIIA-VIIA </span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">nRight</span> <span class="o">&lt;=</span> <span class="mi">10</span> <span class="p">):</span> <span class="c"># IIIV</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">nRight</span> <span class="o">&lt;=</span> <span class="mi">14</span> <span class="p">):</span> <span class="c">#IVB-VIIB</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">18</span><span class="o">-</span><span class="n">nRight</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># La/Ac series</span>
                <span class="n">result</span> <span class="o">=</span> <span class="mi">3</span>            
            <span class="k">break</span>
    <span class="k">return</span> <span class="n">result</span>
        
</div>
<div class="viewcode-block" id="ReadSplitLine"><a class="viewcode-back" href="../main_struct.html#common_caseutil.ReadSplitLine">[docs]</a><span class="k">def</span> <span class="nf">ReadSplitLine</span><span class="p">(</span><span class="n">fIn</span><span class="p">,</span><span class="n">stSep</span><span class="o">=</span><span class="s">&quot;&quot;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read a line from file and split it by default ( no EOL and ignore empty), or split with specific string</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stSep</span><span class="o">==</span><span class="s">&quot;&quot;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fIn</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fIn</span><span class="o">.</span><span class="n">readline</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span>

</div>
<div class="viewcode-block" id="f_IsNumber"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_IsNumber">[docs]</a><span class="k">def</span> <span class="nf">f_IsNumber</span><span class="p">(</span><span class="n">stInput</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Detect if this string can be converted to a float number, return true or false</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">stInput</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">result</span>
    </div>
<div class="viewcode-block" id="f_Data_ReadTwoCol"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Data_ReadTwoCol">[docs]</a><span class="k">def</span> <span class="nf">f_Data_ReadTwoCol</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="n">stComment</span><span class="o">=</span><span class="s">&quot;#&quot;</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read data from empty line seperated two-columns data, which can be read directly by xmgrace </span>
<span class="sd">    This function require all sets in the file must have same number of rows</span>

<span class="sd">    :param stComment: If a line start with this character, then treat it as comment </span>
<span class="sd">    :return: a list of rows</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">bStarted</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">nRow</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nCol</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">stLine</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
        <span class="n">stLine</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">stLine</span><span class="p">)</span> <span class="o">==</span><span class="mi">0</span><span class="p">):</span><span class="c">#Empty line, which means a set end</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">bStarted</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">nRow</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;The </span><span class="si">%i</span><span class="s"> set has different number of rows </span><span class="si">%i</span><span class="s"> from previous </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">nCol</span><span class="p">,</span><span class="n">nRow</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">nRow</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">nCol</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">bStarted</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span><span class="c">#Just skip </span>
                <span class="k">continue</span>
            
        <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;#&quot;</span><span class="p">):</span> <span class="c">#Skip comments</span>
            <span class="k">continue</span>

        <span class="c">#ar = [ float(x) for x in stLine.split()]</span>
        <span class="n">ar</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;There should be only 2 value in one line&quot;</span>
<span class="c">#Find data, mark as started        </span>
        <span class="n">bStarted</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
          <span class="k">if</span> <span class="p">(</span> <span class="n">nCol</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">):</span>
              <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar</span><span class="p">])</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">data</span><span class="p">[</span><span class="n">nRow</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">if</span> <span class="p">(</span> <span class="n">nCol</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">):</span>
              <span class="n">data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">)</span>
          <span class="k">else</span><span class="p">:</span>
              <span class="n">data</span><span class="p">[</span><span class="n">nRow</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nRow</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c">#First set</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">data</span>
</div>
<div class="viewcode-block" id="f_Data_WriteTwoCol"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Data_WriteTwoCol">[docs]</a><span class="k">def</span> <span class="nf">f_Data_WriteTwoCol</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write data to empty line seperated two-columns data, which can be read directly by xmgrace </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span>  <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
    <span class="n">nLen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">row</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nLen</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Row </span><span class="si">%i</span><span class="s"> has different columns from set&quot;</span> <span class="o">%</span> <span class="n">i</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)):</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%14s</span><span class="s">    </span><span class="si">%14s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">])))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="f_Data_ReadMultiCol"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Data_ReadMultiCol">[docs]</a><span class="k">def</span> <span class="nf">f_Data_ReadMultiCol</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="n">stComment</span><span class="o">=</span><span class="s">&quot;#&quot;</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Read data from multi-columns data</span>

<span class="sd">    :param stComment: If a line start with this character, then treat it as comment </span>
<span class="sd">    :param func: the function to convert each element string to specific object</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)</span>
    <span class="n">nCol</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">stLine</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">stLine</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">stLine</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;#&quot;</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="n">ar_stLine</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nCol</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">nCol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar_stLine</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">nCol</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ar_stLine</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Unmatched column number in row #</span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">ar_stLine</span> <span class="o">=</span> <span class="p">[</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ar_stLine</span><span class="p">]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ar_stLine</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="f_Data_WriteMultiCol"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Data_WriteMultiCol">[docs]</a><span class="k">def</span> <span class="nf">f_Data_WriteMultiCol</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">stFileName</span><span class="p">,</span><span class="n">delim</span><span class="o">=</span><span class="s">&quot;  &quot;</span><span class="p">,</span><span class="n">func</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Write data into multi-columns with space seperated </span>

<span class="sd">    :param data: 2-D list contains the data</span>
<span class="sd">    :param stFileName: the output filename</span>
<span class="sd">    :param func: the function to convert element to string. If not specified, set to str()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">func</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">str</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">delim</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">line</span><span class="p">]))</span>
        <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="mi">0</span>
</div>
<div class="viewcode-block" id="f_Data_Write"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Data_Write">[docs]</a><span class="k">def</span> <span class="nf">f_Data_Write</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">b_col</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">b_twocol</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">b_complex</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">b_split</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    This function can write data into files in the two-columns or the multi-columns format.</span>
<span class="sd">    The data is a nested lists, can be row first or column first.</span>

<span class="sd">    :param list_data: list of [x,y1,y2,y3...]</span>
<span class="sd">    :param b_col: the data is in the format of [[x,x,x...],[y1,y1,y1]...</span>
<span class="sd">    :param b_twocol: write the data in two-columns format instead of [x,y1,y2..] format</span>
<span class="sd">    :param b_split: write all real parts of y first and then imaginary parts: x,y1.real,y2.real,...y1.imag,y2.imag...</span>
<span class="sd">    :param b_complex: can be used when the data is complex, the real and imaginary parts will be in different columns</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b_col</span><span class="p">):</span>
        <span class="n">list_data2</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">list_data</span><span class="p">))</span>
        <span class="n">f_Data_Write</span><span class="p">(</span><span class="n">list_data2</span><span class="p">,</span><span class="n">filename</span><span class="p">,</span><span class="n">b_col</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">b_twocol</span><span class="o">=</span><span class="n">b_twocol</span><span class="p">,</span><span class="n">b_complex</span><span class="o">=</span><span class="n">b_complex</span><span class="p">,</span><span class="n">b_split</span><span class="o">=</span><span class="n">b_split</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">b_complex</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b_split</span><span class="p">):</span>
            <span class="n">list_data2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">real</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span><span class="o">+</span><span class="p">[</span><span class="n">y</span><span class="o">.</span><span class="n">imag</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_data</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">list_data2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="nb">sum</span><span class="p">([[</span><span class="n">y</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">y</span><span class="o">.</span><span class="n">imag</span><span class="p">]</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">list_data</span><span class="p">],[])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_data</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">list_data2</span> <span class="o">=</span> <span class="n">list_data</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">b_twocol</span><span class="p">):</span>
        <span class="n">f_Data_WriteTwoCol</span><span class="p">(</span><span class="n">list_data2</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f_Data_WriteMultiCol</span><span class="p">(</span><span class="n">list_data2</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>

    <span class="k">return</span>  
</div>
<div class="viewcode-block" id="NamelistIO"><a class="viewcode-back" href="../main_struct.html#common_caseutil.NamelistIO">[docs]</a><span class="k">class</span> <span class="nc">NamelistIO</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A Class used for Fortran namelist like file I/O</span>
<span class="sd">    Warning: This invokes exec on lines directly, please use with caution!</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">pre_line</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        :param pre_line: Preprocess all input line, accept a string (stripped) and returns a string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span> <span class="o">=</span> <span class="p">{}</span> <span class="c">#! the dictionary include &amp;-/ part</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listExistName</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#! the list contain the order of keys of dicExistName</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#! the file content</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span> <span class="o">=</span> <span class="s">&quot;&quot;</span> <span class="c">#! temp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pre_line</span> <span class="o">=</span> <span class="n">pre_line</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">b_warn_write</span> <span class="o">=</span> <span class="bp">True</span> <span class="c">#! Display warning when overwriting some files </span>

    <span class="nd">@staticmethod</span>
<div class="viewcode-block" id="NamelistIO.default_pre_line"><a class="viewcode-back" href="../main_struct.html#common_caseutil.NamelistIO.default_pre_line">[docs]</a>    <span class="k">def</span> <span class="nf">default_pre_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Treat all &quot;!&quot; as the starting point of a comment</span>
<span class="sd">        Remove all redundant blanks and comments</span>
<span class="sd">        This is used when pre_line is None</span>
<span class="sd">        @todo we don&#39;t check if it is inside a string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ix</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="n">ix</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    </div>
    <span class="k">def</span> <span class="nf">__DetectFileExist__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Detect whether a file is exists, display warning if it is</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">b_warn_write</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\33</span><span class="s">[36mWarning: </span><span class="si">%s</span><span class="s"> already exists! It is overwritten.</span><span class="se">\33</span><span class="s">[m&quot;</span> <span class="o">%</span> <span class="n">stFileName</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__FormatValue__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stValue</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Detect whether a value is a float value, process &#39;d&#39; or &#39;D&#39; to &#39;e&#39;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="s">&#39;&quot;&#39;</span> <span class="ow">in</span> <span class="n">stValue</span> <span class="ow">or</span> <span class="s">&quot;&#39;&quot;</span> <span class="ow">in</span> <span class="n">stValue</span><span class="p">):</span> <span class="c">#string</span>
            <span class="k">return</span> <span class="n">stValue</span>
        <span class="n">stV2</span> <span class="o">=</span> <span class="n">stValue</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stV2</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.true.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">stValue</span> <span class="o">=</span> <span class="n">stV2</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;True&quot;</span> <span class="o">+</span> <span class="n">stV2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">6</span><span class="p">:]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">stV2</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.false.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">stValue</span> <span class="o">=</span> <span class="n">stV2</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot;False&quot;</span> <span class="o">+</span> <span class="n">stV2</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">7</span><span class="p">:]</span>
        <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="n">stValue</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">stValue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;d&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span> <span class="n">stValue</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">stValue</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;D&quot;</span> <span class="p">)</span> <span class="p">):</span> <span class="c"># float</span>
            <span class="c">#ensure float: d must between in 2 digit or &#39;-&#39; and no other digit is allowed</span>
            <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">stValue</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="p">):</span>
                <span class="k">return</span> <span class="n">stValue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stNext</span> <span class="o">=</span> <span class="n">stValue</span><span class="p">[</span><span class="n">stValue</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">stNext</span> <span class="o">!=</span> <span class="s">&quot;-&quot;</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">stNext</span><span class="o">.</span><span class="n">isdigit</span><span class="p">())):</span>
                    <span class="k">return</span> <span class="n">stValue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c">#print ( &quot;Detect float : %s&quot; % stValue)</span>
                    <span class="k">return</span>  <span class="n">stValue</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">stValue</span>
 
    <span class="k">def</span> <span class="nf">__GetNameValue__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stLine</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read a line contain &quot;a=b&quot; </span>
<span class="sd">        Return a</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">arLine</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span>
        <span class="n">stVarName</span> <span class="o">=</span> <span class="n">arLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="c">#treat as empty line</span>
<span class="c">#           print(&quot;Namelist Input Format Error!&quot;)</span>
            <span class="k">return</span> <span class="bp">None</span><span class="p">,</span><span class="bp">None</span>

        <span class="n">stVar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__FormatValue__</span><span class="p">(</span><span class="n">arLine</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">)</span><span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">stVarName</span> <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stVarName</span><span class="p">)):</span><span class="c"># new 100 length array</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stVarName</span><span class="p">,[</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">)])</span>
            <span class="c">#set value</span>
            <span class="c">#split</span>
            <span class="n">reIndex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">pattern</span><span class="o">=</span><span class="s">&quot;(.+)\((.+)\)(.*)&quot;</span><span class="p">)</span>
            <span class="n">aMatch</span> <span class="o">=</span> <span class="n">reIndex</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">arLine</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">aMatch</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">stVarNameTotal</span> <span class="o">=</span> <span class="n">aMatch</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;[&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">aMatch</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">)))</span><span class="o">+</span><span class="s">&quot;]&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Quamtum-Espresso Input Format Error!&quot;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">FormatError</span><span class="p">,</span><span class="s">&quot;Quamtum-Espresso Input Format Error!&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stVarNameTotal</span> <span class="o">=</span> <span class="n">stVarName</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">exec</span><span class="p">(</span><span class="s">&quot;self.&quot;</span><span class="o">+</span><span class="n">stVarNameTotal</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">+</span><span class="s">&quot;=&quot;</span><span class="o">+</span><span class="n">stVar</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span><span class="c">#Treated as a string</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stVarNameTotal</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span><span class="n">stVar</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">stVarName</span><span class="p">,</span> <span class="n">stVar</span>
    
    <span class="k">def</span> <span class="nf">__ToStringFromName__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stName</span><span class="p">,</span><span class="n">nMaxIndex</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a Name = Value string</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stName</span><span class="p">)</span> <span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error: Invalid property </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">stName</span><span class="p">)</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span>

        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;  &quot;</span><span class="o">+</span> <span class="n">stName</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stName</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ToStringFromNameValue__</span><span class="p">(</span><span class="n">stName</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">nMaxIndex</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">__ToStringFromNameValue__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stName</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">nMaxIndex</span> <span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create a Name = Value string, value comes from self.name</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;  &quot;</span><span class="o">+</span> <span class="n">stName</span> <span class="o">+</span> <span class="s">&quot; = &quot;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">bool</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">value</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;.true.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;.false.&quot;</span>        
        <span class="k">elif</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">int</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">float</span><span class="p">)):</span>
            <span class="k">if</span><span class="p">(</span><span class="n">value</span> <span class="o">&lt;=</span> <span class="mf">0.001</span> <span class="ow">and</span> <span class="n">value</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mf">0.001</span><span class="p">):</span> <span class="c"># common converge standard like 1d-10</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%2.2e</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="s">&quot;d&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">str</span><span class="p">)):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;&#39;&quot;</span><span class="o">+</span><span class="n">value</span><span class="o">+</span><span class="s">&quot;&#39;&quot;</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="nb">list</span><span class="p">)):</span> <span class="c"># array list, if &lt; 0 then treat as not output</span>
            <span class="n">result</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span> <span class="c">#ignore value[0] </span>
                <span class="k">if</span><span class="p">(</span> <span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c">#ignore -1 float type ( in pw.x celldm )</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ToStringFromNameValue__</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s</span><span class="s">(</span><span class="si">%d</span><span class="s">)&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">stName</span><span class="p">,</span><span class="n">i</span><span class="p">),</span><span class="n">value</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">nMaxIndex</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Unsupported type : </span><span class="si">%s</span><span class="s"> = </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stName</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
        <span class="c">#print(&quot;line:&quot; + result)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">result</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">return</span> <span class="n">result</span>
    
    <span class="k">def</span> <span class="nf">__WriteNameValue__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">fOut</span><span class="p">,</span><span class="n">stPart</span><span class="p">,</span><span class="n">list_stName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Write a part </span>
<span class="sd">        including:</span>
<span class="sd">        part name,  (if part name is not empty)</span>
<span class="sd">        all Name = value string in list_stName,</span>
<span class="sd">        and all name readed</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stPart</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
            <span class="n">fOut</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;&amp;</span><span class="si">%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">stPart</span><span class="p">)</span>
        <span class="c">#write readed</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="n">stPart</span><span class="p">)):</span>
            <span class="n">listNameRead</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="n">stPart</span><span class="p">]</span>
            <span class="c">#print(&quot;find %s&quot; % stPart)</span>
            <span class="c">#print(listNameRead)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">listNameRead</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="c">#print(&quot;Not find %s&quot; % stPart)</span>
        
        <span class="k">for</span> <span class="n">stName</span> <span class="ow">in</span> <span class="n">listNameRead</span><span class="p">:</span>
            <span class="c">#print(&quot;In Readed: &quot; + stName)</span>
            <span class="n">fOut</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ToStringFromName__</span><span class="p">(</span><span class="n">stName</span><span class="p">))</span>
        
        <span class="k">for</span> <span class="n">stName</span> <span class="ow">in</span> <span class="n">list_stName</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">stName</span> <span class="ow">in</span> <span class="n">listNameRead</span><span class="p">):</span>
                <span class="c">#print(&quot;In Specific: &quot; + stName)</span>
                <span class="n">fOut</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ToStringFromName__</span><span class="p">(</span><span class="n">stName</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
                <span class="c">#print(&quot;Duplicate: &quot; + stName)            </span>

        <span class="k">if</span> <span class="p">(</span><span class="n">stPart</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
            <span class="n">fOut</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot;/</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__AddPart__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name_part</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a part in the index</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#print(&quot;Add Part %s&quot; % stLine[1:].strip())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span> <span class="o">=</span> <span class="n">name_part</span> 
        <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span><span class="p">]</span><span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listExistName</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__ProcessLine__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">i0</span><span class="p">,</span><span class="n">stLineOrg</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Process a line in standard way. The two parameters is for convienience to edit.</span>

<span class="sd">        :param i0: the line number</span>
<span class="sd">        :param stLineOrg: the line content</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span>
        <span class="n">stLine</span> <span class="o">=</span> <span class="n">NamelistIO</span><span class="o">.</span><span class="n">default_pre_line</span><span class="p">(</span><span class="n">stLineOrg</span><span class="p">)</span>
        <span class="c"># normal part</span>
        <span class="k">while</span><span class="p">(</span><span class="bp">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">stLine</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span> <span class="c"># skip empty line</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&amp;&#39;</span> <span class="ow">or</span> <span class="n">stLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;/&quot;</span> <span class="p">):</span> <span class="c">#mark line, skip</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;&amp;&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__AddPart__</span><span class="p">(</span><span class="n">stLine</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">break</span>
            <span class="c"># comma split</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">stLine</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c"># split &#39;,&#39;</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">stSplit</span> <span class="ow">in</span> <span class="n">stLine</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">stSplit</span><span class="p">)</span>
                <span class="k">break</span>
            <span class="n">stCurrentName</span><span class="p">,</span><span class="n">var_tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__GetNameValue__</span><span class="p">(</span><span class="n">stLine</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stCurrentName</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span> <span class="o">==</span> <span class="s">&quot;&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="o">.</span><span class="n">has_key</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">__AddPart__</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">)</span>
            <span class="c">#print(&quot;Current Name %s in part %s&quot; % (stCurrentName,stCurrentPart))</span>
                <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">stCurrentName</span> <span class="ow">in</span>  <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stCurrentName</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">break</span>
        <span class="k">return</span> <span class="n">i</span>
    
<div class="viewcode-block" id="NamelistIO.AddValue"><a class="viewcode-back" href="../main_struct.html#common_caseutil.NamelistIO.AddValue">[docs]</a>    <span class="k">def</span> <span class="nf">AddValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">part</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a name=value contained in specific &amp;part/</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">part</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="n">part</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listExistName</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">part</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="n">part</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dicExistName</span><span class="p">[</span><span class="n">part</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">)</span>
    </div>
<div class="viewcode-block" id="NamelistIO.WriteToFile"><a class="viewcode-back" href="../main_struct.html#common_caseutil.NamelistIO.WriteToFile">[docs]</a>    <span class="k">def</span> <span class="nf">WriteToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Write content to one file in Quantum-Espresso readable format</span>
<span class="sd">        &#39;&#39;&#39;</span>        
        <span class="bp">self</span><span class="o">.</span><span class="n">__DetectFileExist__</span><span class="p">(</span><span class="n">stFileName</span><span class="p">)</span>
        <span class="n">fOut</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stPart</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listExistName</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__WriteNameValue__</span><span class="p">(</span><span class="n">fOut</span><span class="p">,</span><span class="n">stPart</span><span class="p">,[])</span>
    </div>
<div class="viewcode-block" id="NamelistIO.ReadFromFile"><a class="viewcode-back" href="../main_struct.html#common_caseutil.NamelistIO.ReadFromFile">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFromFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read content from one file in Fortran namelist format</span>
<span class="sd">        &#39;&#39;&#39;</span>              
        <span class="n">fIn</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span> <span class="o">=</span> <span class="n">fIn</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stCurrentPart</span> <span class="o">=</span> <span class="s">&quot;&quot;</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span><span class="p">)):</span>
            <span class="n">stLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&quot;pre_line&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_line</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">stLine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pre_line</span><span class="p">(</span><span class="n">stLine</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ProcessLine__</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">stLine</span><span class="p">)</span>
        <span class="c">#clean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">list_stLine</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">pass</span>    
</div></div>
<div class="viewcode-block" id="RawFileIO"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO">[docs]</a><span class="k">class</span> <span class="nc">RawFileIO</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A class represents a files which can be used for IO</span>
<span class="sd">    It keeps exactly every line in the file, and won&#39;t lost anything between I/O, but still support value edit and addition (&quot;\\n&quot; is stored)</span>
<span class="sd">    It is suitable to edit files that have large parts not concerned by us, but should not be modified, and it is not worth to encode a full I/O for it. </span>
<span class="sd">    Its efficiency is a hell but still always faster than QM calculation so do not bother it.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

<div class="viewcode-block" id="RawFileIO.read"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO.read">[docs]</a>    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read a file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RawFileIO.write"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Write to a file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
</div>
<div class="viewcode-block" id="RawFileIO.find_marked_line"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO.find_marked_line">[docs]</a>    <span class="k">def</span> <span class="nf">find_marked_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mark</span><span class="p">,</span><span class="n">num_shift</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">ix_start</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the index of line, with specific number of lines before/after its line</span>

<span class="sd">        :param mark: the string which the first appear should be found</span>
<span class="sd">        :param num_shift: the i-th line after the marked line(can be 0 or negative)</span>
<span class="sd">        :param ix_start: which line the search should start, start at 0</span>
<span class="sd">        :return: the line index, if not found return 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ix_start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">ix_start</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">):</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">mark</span> <span class="ow">in</span> <span class="n">line</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">i</span><span class="o">+</span><span class="n">num_shift</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    </div>
    <span class="k">def</span> <span class="nf">__is_float__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">st</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine whether a string is float number</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">and</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;-&quot;</span> <span class="ow">and</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;+&quot;</span> <span class="ow">and</span> <span class="n">st</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;.&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">)):</span>
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span> <span class="c">#Possibly A[d,e,E,D][+,-]B</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;.&quot;</span><span class="p">):</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="s">&quot;E&quot;</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;+&quot;</span> <span class="ow">or</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span> <span class="ow">or</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">elif</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;+&quot;</span> <span class="ow">or</span> <span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;D&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">,</span><span class="s">&quot;E&quot;</span><span class="p">)):</span>
                        <span class="k">return</span> <span class="bp">False</span>
                <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span>


<div class="viewcode-block" id="RawFileIO.edit_value"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO.edit_value">[docs]</a>    <span class="k">def</span> <span class="nf">edit_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ix_line</span><span class="p">,</span><span class="n">value</span><span class="p">,</span><span class="n">pos_end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Edit the value in the line, assuming only one value is presented in the line</span>
<span class="sd">        there are several way to guess it:</span>
<span class="sd">        1. after first &quot;=&quot;</span>
<span class="sd">        2. first number </span>
<span class="sd">        if pos_end is used then look for the position </span>
<span class="sd">        if name is used then look for the name</span>

<span class="sd">        :param ix_line: the line index which to be edited</span>
<span class="sd">        :param value: the value which should be set</span>
<span class="sd">        :param pos_end: the end position of the value which is to be set</span>
<span class="sd">        :param name: the value just after name will be set ( possibly skip a &quot;=&quot; )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">ix_line</span><span class="p">]</span>
<span class="c">#Find the position of the number</span>
        <span class="n">pos_start</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c">#Start of the number</span>
        <span class="n">pos_space</span> <span class="o">=</span> <span class="mi">0</span> <span class="c">#Start of empty before the number</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pos_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">pos_start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">pos_end</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s">&quot; &quot;</span> <span class="ow">or</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="s">&quot;=&quot;</span><span class="p">):</span> <span class="c">#Space or &quot;=&quot; split</span>
                    <span class="n">pos_start</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
<span class="c">#Find name seperated</span>
<span class="c">#pos_space start from just after &quot;=&quot; or the name</span>
            <span class="n">pos_end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c">#End of the number </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">pos_space</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pos_space</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s">&quot;Cannot find specific name </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">pos_space</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="c">#Find &quot;=&quot;</span>
            <span class="n">pos_space</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">,</span><span class="n">pos_space</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos_space</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">pos_space</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="c">#Forward search value</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">pos_space</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot; &quot;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">):</span>
                        <span class="n">pos_start</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pos_start</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s">&quot;Cannot find any number in line&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
<span class="c">#No sign &quot;=&quot;</span>
<span class="c">#Find the first number</span>
<span class="c">#pos_start start from the digit or &quot;-xxx&quot;</span>
                <span class="n">pos_space</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">pos_space</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                        <span class="n">pos_start</span> <span class="o">=</span> <span class="n">i</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">pos_start</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span> <span class="c">#Found</span>
<span class="c">#Check negative character</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">pos_start</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="n">pos_start</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;-&#39;</span><span class="p">):</span>
                        <span class="n">pos_start</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s">&quot;Cannot find any number in line&quot;</span><span class="p">)</span>
<span class="c">#Backward search empty space</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">pos_start</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot; &quot;</span><span class="p">):</span>
                        <span class="n">pos_space</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="k">break</span>
            <span class="c">#Find end</span>
            <span class="n">b_inword</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">pos_end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">pos_start</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">b_inword</span> <span class="ow">and</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot; &quot;</span> <span class="ow">or</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)):</span>
                    <span class="n">pos_end</span> <span class="o">=</span> <span class="n">i</span><span class="o">-</span><span class="mi">1</span>
                    <span class="k">break</span>
                <span class="n">b_inword</span> <span class="o">=</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot; &quot;</span> <span class="ow">and</span> <span class="n">line</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">)</span>

        <span class="c">#Use available spaces for editing</span>
        <span class="c">#Try find floating format</span>
        <span class="c">#Is it a floating number?</span>
        <span class="n">st_org</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="n">pos_start</span><span class="p">:</span><span class="n">pos_end</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
<span class="c">#Replace d,D,E to e</span>
        <span class="n">st_org</span> <span class="o">=</span> <span class="n">st_org</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;d&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;D&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s">&quot;E&quot;</span><span class="p">,</span><span class="s">&quot;e&quot;</span><span class="p">)</span>
        <span class="n">b_float</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__is_float__</span><span class="p">(</span><span class="n">st_org</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b_float</span><span class="p">):</span>
<span class="c">#Try to find the format</span>
            <span class="k">if</span> <span class="p">(</span><span class="s">&quot;e&quot;</span> <span class="ow">in</span> <span class="n">st_org</span><span class="p">):</span>
<span class="c">#%e</span>
                <span class="k">if</span> <span class="p">(</span><span class="s">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">st_org</span><span class="p">):</span>
                    <span class="n">num_decimal</span> <span class="o">=</span> <span class="n">st_org</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;e&quot;</span><span class="p">)</span><span class="o">-</span><span class="n">st_org</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">num_decimal</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">st_val</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%%%i</span><span class="s">.</span><span class="si">%i</span><span class="s">e&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos_end</span><span class="o">-</span><span class="n">pos_space</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">num_decimal</span><span class="p">)</span>
                <span class="n">st_val</span> <span class="o">=</span> <span class="n">st_val</span> <span class="o">%</span> <span class="n">value</span>
            <span class="k">else</span><span class="p">:</span>
<span class="c">#%f</span>
                <span class="n">num_decimal</span> <span class="o">=</span> <span class="n">pos_end</span><span class="o">-</span><span class="n">st_org</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;.&quot;</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
                <span class="n">st_val</span> <span class="o">=</span> <span class="s">&quot;</span><span class="si">%%%i</span><span class="s">.</span><span class="si">%i</span><span class="s">f&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos_end</span><span class="o">-</span><span class="n">pos_space</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">num_decimal</span><span class="p">)</span>
                <span class="n">st_val</span> <span class="o">=</span> <span class="n">st_val</span> <span class="o">%</span> <span class="n">value</span> 
        <span class="k">else</span><span class="p">:</span>
<span class="c">#Fill with new value</span>
            <span class="n">st_val</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">st_val</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pos_end</span><span class="o">-</span><span class="n">pos_space</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pos_end</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">())):</span>
                <span class="k">raise</span> <span class="n">FormatError</span><span class="p">(</span><span class="s">&quot;Not enough space in line&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="n">pos_space</span><span class="p">]</span> <span class="o">+</span> <span class="n">st_val</span> <span class="o">+</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="n">pos_end</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">st_val</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">st_val</span> <span class="o">+</span> <span class="n">line</span><span class="p">[</span><span class="n">pos_end</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">[</span><span class="n">ix_line</span><span class="p">]</span> <span class="o">=</span> <span class="n">line</span>

        <span class="k">return</span>
</div>
<div class="viewcode-block" id="RawFileIO.edit_name_value"><a class="viewcode-back" href="../main_struct.html#common_caseutil.RawFileIO.edit_name_value">[docs]</a>    <span class="k">def</span> <span class="nf">edit_name_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Edit name = value type string</span>
<span class="sd">        if name does not exist, then add one</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edit_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">find_marked_line</span><span class="p">(</span><span class="n">name</span><span class="p">),</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">FormatError</span><span class="p">:</span>
<span class="c">#Not found, so we just add one</span>
<span class="c">#Try to find where is &quot;=&quot;</span>
<span class="c">#           traceback.print_exc()</span>
            <span class="n">pos_eq</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;=&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="p">]</span>
            <span class="n">pos_max</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">pos_eq</span><span class="p">)),</span>
                    <span class="n">key</span><span class="o">=</span><span class="k">lambda</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">v</span><span class="p">):(</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">v</span><span class="p">)),</span><span class="o">-</span><span class="n">pos_eq</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">x</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos_max</span> <span class="o">=</span> <span class="n">pos_max</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">&gt;</span><span class="n">pos_max</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">name2</span> <span class="o">=</span> <span class="n">name</span> <span class="o">+</span><span class="s">&quot; = &quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">name2</span> <span class="o">=</span> <span class="p">(</span><span class="s">&quot;</span><span class="si">%%%i</span><span class="s">s = &quot;</span> <span class="o">%</span> <span class="n">pos_max</span><span class="p">)</span> <span class="o">%</span> <span class="n">name</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%s%s</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name2</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>

        <span class="k">return</span>
</div></div>
<div class="viewcode-block" id="f_Split_EnumerateRangeString"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Split_EnumerateRangeString">[docs]</a><span class="k">def</span> <span class="nf">f_Split_EnumerateRangeString</span><span class="p">(</span><span class="n">stRange</span><span class="p">,</span><span class="n">stRangeType</span><span class="o">=</span><span class="s">&quot;mms&quot;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a list of all possible combination from a string</span>
<span class="sd">    string format : PropertyA:20,40,50~100~10;PropertyB_x:4~12~2</span>
<span class="sd">    &quot;_x&quot; after name means relative value ( used for ecutrho, which is relative to ecutwfc)</span>
<span class="sd">    relative value will be set in the order of string, </span>
<span class="sd">    if ecutrho_x is before ecutwfc, it will be used as ecutwfc in original input file * parameter </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">listProperty</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">arList1</span> <span class="o">=</span> <span class="n">stRange</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">stProperty</span> <span class="ow">in</span> <span class="n">arList1</span><span class="p">:</span>
        <span class="p">(</span><span class="n">stName</span><span class="p">,</span><span class="n">stValue</span><span class="p">)</span> <span class="o">=</span> <span class="n">stProperty</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;:&quot;</span><span class="p">)</span>
        <span class="n">listProperty</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">stName</span><span class="p">,</span><span class="n">f_Split_RangeString</span><span class="p">(</span><span class="n">stValue</span><span class="p">,</span><span class="n">stRangeType</span><span class="p">)])</span>    
    
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">stName</span><span class="p">,</span><span class="n">aProperty</span><span class="p">)</span> <span class="ow">in</span> <span class="n">listProperty</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">result</span> <span class="o">==</span> <span class="p">[]):</span>
            <span class="k">for</span> <span class="n">aValue</span> <span class="ow">in</span> <span class="n">aProperty</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">stName</span><span class="p">,</span><span class="n">aValue</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">aValue</span> <span class="ow">in</span> <span class="n">aProperty</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">aPart</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                    <span class="n">aPart2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aPart</span><span class="p">)</span>
                    <span class="n">aPart2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">stName</span><span class="p">,</span><span class="n">aValue</span><span class="p">])</span>
                    <span class="n">result2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aPart2</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result2</span>
<span class="c">#   print(result)         </span>
    <span class="k">return</span> <span class="n">result</span> 

</div>
<div class="viewcode-block" id="f_Split_RangeString"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Split_RangeString">[docs]</a><span class="k">def</span> <span class="nf">f_Split_RangeString</span><span class="p">(</span><span class="n">stRange</span><span class="p">,</span><span class="n">stRangeType</span><span class="o">=</span><span class="s">&quot;mms&quot;</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate a list of number from string.</span>
<span class="sd">    String format: a,b,c,d~e~f,h,... ( every character represent a float value)</span>
<span class="sd">    &#39;,&#39; seperate different value</span>
<span class="sd">    &#39;a~b~c&#39; define a list of a,a+c,a+2*c,...a+n*c, until a+n*c &gt; b ( if a &lt;b) or a+n*c &lt; b ( if a &gt; b)</span>
<span class="sd">    which means 1~3~1 -&gt; 1,2,3</span>
<span class="sd">    if a contains non-digit character, the value will be stored as string</span>
<span class="sd">    if &quot;~&quot; is used, the value will be stored as float; otherwise string</span>
<span class="sd">    </span>
<span class="sd">    :param stRange: the string you wanna to split</span>
<span class="sd">    :param stRangeType: define what a~b~c represent , &#39;mms&#39; means min-max-step, &#39;msm&#39; means min-step-max</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">arList</span> <span class="o">=</span> <span class="n">stRange</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">aPart</span> <span class="ow">in</span> <span class="n">arList</span><span class="p">:</span>          
        <span class="n">arList2</span> <span class="o">=</span> <span class="n">aPart</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&quot;~&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">arList2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">stRangeType</span> <span class="o">==</span> <span class="s">&quot;mms&quot;</span><span class="p">):</span>
                <span class="p">(</span><span class="n">fStart</span><span class="p">,</span><span class="n">fEnd</span><span class="p">,</span><span class="n">fStep</span><span class="p">)</span> <span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arList2</span><span class="p">]</span>
                <span class="c">#(fStart,fEnd,fStep) =arList2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="p">(</span><span class="n">fStart</span><span class="p">,</span><span class="n">fStep</span><span class="p">,</span><span class="n">fEnd</span><span class="p">)</span> <span class="o">=</span><span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arList2</span><span class="p">]</span>
                <span class="c">#(fStart,fEnd,fStep) =arList2</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">arList2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;0&quot;</span> <span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ZeroDivisionError</span><span class="p">,</span><span class="s">&quot;Cycle Step cannot be 0!&quot;</span>
            <span class="c">#Always use float for this </span>
            <span class="c">#</span>
            <span class="n">i</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">fStart</span><span class="p">)</span>
            <span class="n">d1</span> <span class="o">=</span> <span class="n">fEnd</span><span class="o">-</span><span class="n">fStart</span>
            <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">d1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">1e-8</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Start/End value must be different : </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">aPart</span><span class="p">)</span>
            <span class="k">while</span> <span class="p">(</span> <span class="p">(</span><span class="n">fEnd</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">*</span><span class="n">d1</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">):</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">fStep</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#if ( aPart.replace(&quot;-&quot;,&quot;&quot;).replace(&quot;.&quot;,&quot;&quot;).isdigit()):</span>
            <span class="c">#    #result.append(float(aPart))</span>
            <span class="c">#    result.append(aPart)</span>
            <span class="c">#else:</span>
            <span class="c">#    result.append(aPart)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aPart</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="f_SolveCross"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_SolveCross">[docs]</a><span class="k">def</span> <span class="nf">f_SolveCross</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span><span class="n">s2</span><span class="p">,</span><span class="n">s3</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find minimum integer solution for UxV = nS</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="p">(</span><span class="n">u1</span><span class="p">,</span><span class="n">u2</span><span class="p">,</span><span class="n">u3</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">n</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="c">#test 0-9 for u-n</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">nMax</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">u1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">u2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">u3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">v3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">nMax</span><span class="p">,</span><span class="n">nMax</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span> <span class="n">u2</span><span class="o">*</span><span class="n">v3</span><span class="o">-</span><span class="n">u3</span><span class="o">*</span><span class="n">v2</span> <span class="o">==</span> <span class="n">n</span><span class="o">*</span><span class="n">s1</span> <span class="ow">and</span> <span class="n">u3</span><span class="o">*</span><span class="n">v1</span><span class="o">-</span><span class="n">u1</span><span class="o">*</span><span class="n">v3</span> <span class="o">==</span> <span class="n">n</span><span class="o">*</span><span class="n">s2</span> <span class="ow">and</span> <span class="n">u1</span><span class="o">*</span><span class="n">v2</span><span class="o">-</span><span class="n">u2</span><span class="o">*</span><span class="n">v1</span> <span class="o">==</span> <span class="n">n</span><span class="o">*</span><span class="n">s3</span> <span class="p">):</span>
                                    <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">u3</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span><span class="o">+</span><span class="nb">abs</span><span class="p">(</span><span class="n">v3</span><span class="p">),[</span><span class="n">u1</span><span class="p">,</span><span class="n">u2</span><span class="p">,</span><span class="n">u3</span><span class="p">,</span><span class="n">v1</span><span class="p">,</span><span class="n">v2</span><span class="p">,</span><span class="n">v3</span><span class="p">,</span><span class="n">n</span><span class="p">]</span> <span class="p">))</span>
    <span class="n">result</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span>


</div>
<div class="viewcode-block" id="f_MaxCommonSubmultiple"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_MaxCommonSubmultiple">[docs]</a><span class="k">def</span> <span class="nf">f_MaxCommonSubmultiple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    return maximum common submultiple of two integer</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">b</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">f_MaxCommonSubmultiple</span><span class="p">(</span><span class="n">b</span> <span class="o">%</span> <span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="f_MinCommonMultiple"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_MinCommonMultiple">[docs]</a><span class="k">def</span> <span class="nf">f_MinCommonMultiple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    return minimum common multiple of two integer</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">b</span><span class="o">/</span><span class="n">f_MaxCommonSubmultiple</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">))</span>
</div>
<div class="viewcode-block" id="f_GetSurfaceFromMiller"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_GetSurfaceFromMiller">[docs]</a><span class="k">def</span> <span class="nf">f_GetSurfaceFromMiller</span><span class="p">(</span><span class="n">list_index</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get three vectors ( base cell vectors ) perpendicular to specific miller index</span>
<span class="sd">    :return: first two make the surface , the third make it a cell </span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;Millier index must has 3 integer&quot;</span>
    <span class="c">#detect if 0 exist</span>
    <span class="c">#b0 = 0 in list_index</span>
    <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="c">#revIndex = []</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c">#select non-0 value in the miller index</span>
    <span class="c">#select a vector from one point of miller surface cross point with axis plane to another</span>
    <span class="c">#(this line is useless now)note due to symmetry, (1,0,0) -&gt; (0,1,0) = -1,1,0 = 1,1,0, so only positive is used </span>
    <span class="c">#if one of its index is 0, use 1 as vector, otherwise use min common multiple</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">list_index</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">break</span>
    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">base</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> 
        <span class="k">if</span> <span class="p">(</span> <span class="n">list_index</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">CM</span> <span class="o">=</span> <span class="n">f_MinCommonMultiple</span><span class="p">(</span><span class="n">list_index</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">list_index</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">CM</span> <span class="o">/</span> <span class="n">list_index</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">base</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">CM</span> <span class="o">/</span> <span class="n">list_index</span><span class="p">[</span><span class="n">index</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
    <span class="c"># find c axis has minimum number</span>
    <span class="c">#try linear combiniation to find lowest </span>
    <span class="c">#dMin = lu.f_List_dot3(result[0], result[1])</span>
    <span class="c">#listLM = copy.deepcopy(result)</span>
    <span class="c">#for i in range(-1,1):</span>
    <span class="c">#    for j in range(-1,1):</span>
    <span class="c">#        vA = lu.f_List_Op_List(result[0],&#39;+&#39;,lu.f_List_Op_Scalar(result[1],&quot;*&quot;,i))</span>
    <span class="c">#        vB = lu.f_List_Op_List(result[1],&#39;+&#39;,lu.f_List_Op_Scalar(result[0],&quot;*&quot;,j))</span>
    <span class="c">#        if ( lu.f_List_IsParallel(vA, vB)):</span>
    <span class="c">#            continue</span>
    <span class="c">#        dV = lu.f_List_norm3(lu.f_List_cross3(vA, vB))</span>
    <span class="c">#        if ( dV &lt; dMin - 0.00001 ):</span>
    <span class="c">#            print(i,j,dV)</span>
    <span class="c">#            dMin = dV</span>
    <span class="c">#            listLM = [vA,vB]</span>
    <span class="c">#result = listLM</span>
    
    <span class="n">result</span><span class="o">.</span><span class="n">append</span> <span class="p">(</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_cross3</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])])</span> 
    <span class="k">return</span> <span class="n">result</span>
    
</div>
<div class="viewcode-block" id="f_RotateMatrix"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_RotateMatrix">[docs]</a><span class="k">def</span> <span class="nf">f_RotateMatrix</span><span class="p">(</span><span class="n">dAngle</span><span class="p">,</span><span class="n">vec</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Create a rotation matrix from angle and vector ( vector will be convert to unit vector )</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">vRot</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_normalize</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>
    <span class="n">mRot</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">cosA</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">dAngle</span><span class="p">)</span>
    <span class="n">sinA</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">dAngle</span><span class="p">)</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>    
    <span class="k">return</span> <span class="n">mRot</span>
</div>
<div class="viewcode-block" id="ConvertLatticeToCartesian"><a class="viewcode-back" href="../main_struct.html#common_caseutil.ConvertLatticeToCartesian">[docs]</a><span class="k">def</span> <span class="nf">ConvertLatticeToCartesian</span><span class="p">(</span><span class="n">fLatticeParameter</span><span class="p">,</span><span class="n">fLatticeAngle</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert lattice parameter+angle to Bravis matrix( Numpy array )</span>
<span class="sd">    </span>
<span class="sd">    :param fLatticeAngle: should in unit of degree</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fAngleRad</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">/</span><span class="mf">180.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fLatticeAngle</span><span class="p">]</span>
    <span class="c">#print(fLatticeAngle)</span>
    <span class="c">#print(fAngleRad)</span>
    
    <span class="c">#fCosGamma0 = (math.cos(fAngleRad[2])-math.cos(fAngleRad[0])*math.cos(fAngleRad[1]))/math.sin(fAngleRad[0])/math.sin(fAngleRad[1])</span>
    <span class="n">fCosGamma0</span> <span class="o">=</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    
    <span class="c">#print(fCosGamma0)</span>
    
    <span class="n">fGamma0</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">fCosGamma0</span><span class="p">)</span>
    
    <span class="c">#print(fGamma0*180.0/math.pi)</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    
    <span class="c">#set a-axis as [a,0,0], a-b in a plane of axis</span>
<span class="c">#    result[2,2] = math.sin(fGamma0)*math.sin(fAngleRad[1])*fLatticeParameter[2]</span>
<span class="c">#    result[2,1] = math.cos(fGamma0)*math.sin(fAngleRad[1])*fLatticeParameter[2]</span>
<span class="c">#    result[2,0] = math.cos(fAngleRad[1])*fLatticeParameter[2]</span>
<span class="c">#    result[1,2] = 0</span>
<span class="c">#    result[1,1] = math.sin(fAngleRad[0])*fLatticeParameter[1]</span>
<span class="c">#    result[1,0] = math.cos(fAngleRad[0])*fLatticeParameter[1]</span>
<span class="c">#    result[0,2] = 0</span>
<span class="c">#    result[0,1] = 0</span>
<span class="c">#    result[0,0] = 1*fLatticeParameter[0]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fGamma0</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fGamma0</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">fAngleRad</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="c">#print(math.cos(fAngleRad[2]),fAngleRad[2]*180.0/math.pi)</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="o">*</span><span class="n">fLatticeParameter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    
    <span class="c">#set c-axis as [0,0,c] b-c in a plane of axis</span>
<span class="c">#    result[0,0] = math.sin(fGamma0)*math.sin(fAngleRad[1])*fLatticeParameter[0]</span>
<span class="c">#    result[0,1] = math.cos(fGamma0)*math.sin(fAngleRad[1])*fLatticeParameter[0]</span>
<span class="c">#    result[0,2] = math.cos(fAngleRad[1])*fLatticeParameter[0]</span>
<span class="c">#    result[1,0] = 0</span>
<span class="c">#    result[1,1] = math.sin(fAngleRad[0])*fLatticeParameter[1]</span>
<span class="c">#    result[1,2] = math.cos(fAngleRad[0])*fLatticeParameter[1]</span>
<span class="c">#    result[2,0] = 0</span>
<span class="c">#    result[2,1] = 0</span>
<span class="c">#    result[2,2] = 1*fLatticeParameter[2]</span>
    
    
    
    <span class="c">#print(result)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="ConvertCartesianToLattice"><a class="viewcode-back" href="../main_struct.html#common_caseutil.ConvertCartesianToLattice">[docs]</a><span class="k">def</span> <span class="nf">ConvertCartesianToLattice</span><span class="p">(</span><span class="n">listBravis</span><span class="p">,</span><span class="n">nLatticeType</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert Bravis matrix to 3 parameter + 3 angle</span>

<span class="sd">    :param listBravis: Bravis matrix</span>
<span class="sd">    :param nBravis: represent bravis type, will convert primitive lattice to convetional lattice according to this.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fBravis</span> <span class="o">=</span> <span class="n">listBravis</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">fBravis</span>
    <span class="n">resultAngle</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">]</span>
  
    <span class="c">#print(numpy.dot(result[1,:],result[2,:]))</span>
    <span class="c">#print(lu.f_List_norm3(result[1,:]))</span>
    <span class="c">#print(fBravis[:,0])</span>
    
    <span class="n">resultAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_angle3</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">resultAngle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_angle3</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">resultAngle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_angle3</span><span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">resultAngleDeg</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">180</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">resultAngle</span><span class="p">]</span>
    
    <span class="n">resultLength</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
        <span class="n">resultLength</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">fBravis</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>        
    <span class="c"># centered lattice; this function has been removed into Lattice class</span>
<span class="c">#    if ( nLatticeType == 2 or nLatticeType == 10 ): # fc</span>
<span class="c">#        resultAngleDeg = [90.0,90.0,90.0]</span>
<span class="c">#        resultLength[0] = result[0,0]*2</span>
<span class="c">#        resultLength[1] = result[1,1]*2</span>
<span class="c">#        resultLength[2] = result[2,2]*2</span>
<span class="c">#    elif ( nLatticeType == 3 or nLatticeType == 7 or nLatticeType == 11 ): # bc</span>
<span class="c">#        resultAngleDeg = [90.0,90.0,90.0]</span>
<span class="c">#        resultLength[0] = abs(result[0,0]*2)</span>
<span class="c">#        resultLength[1] = abs(result[0,1]*2)</span>
<span class="c">#        resultLength[2] = abs(result[0,2]*2)</span>
<span class="c">#    elif ( nLatticeType == 9): # boc ortho</span>
<span class="c">#        resultAngleDeg = [90.0,90.0,90.0]</span>
<span class="c">#        resultLength[0] = abs(result[0,0]*2)</span>
<span class="c">#        resultLength[1] = abs(result[0,1]*2)</span>
<span class="c">#        resultLength[2] = abs(result[2,2]*2)        </span>
<span class="c">#    elif ( nLatticeType == 13 ): #boc monoclinic</span>
<span class="c">#        #b = lu.f_List_norm3(numpy.matrix(result[1,:]))</span>
<span class="c">#        b = lu.f_List_norm3(result[1])</span>
<span class="c">#        resultAngleDeg = [90.0,90.0,math.acos(result[1,0]/b)/math.pi * 180]</span>
<span class="c">#        resultLength[0] = abs(result[0,0]*2)</span>
<span class="c">#        #resultLength[1] = lu.f_List_norm3(numpy.matrix(result[1,:]))</span>
<span class="c">#        resultLength[1] = lu.f_List_norm3(result[1])</span>
<span class="c">#        resultLength[2] = abs(result[0,2]*2)</span>
<span class="c">#    elif ( nLatticeType == 5):#R</span>
<span class="c">#        resultAngleDeg = [90.0,90.0,120]</span>
<span class="c">#        resultLength[0] = abs(result[0,0]*2)</span>
<span class="c">#        resultLength[1] = abs(result[0,1]*math.sqrt(3)*2)</span>
<span class="c">#        resultLength[2] = abs(result[0,2]*3)        </span>
        
               
    <span class="k">return</span> <span class="n">resultLength</span><span class="p">,</span><span class="n">resultAngleDeg</span>

</div>
<div class="viewcode-block" id="ConvertInnerCoordToCartesian"><a class="viewcode-back" href="../main_struct.html#common_caseutil.ConvertInnerCoordToCartesian">[docs]</a><span class="k">def</span> <span class="nf">ConvertInnerCoordToCartesian</span><span class="p">(</span><span class="n">fCell</span><span class="p">,</span><span class="n">listInner</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert inner coordinate to cartesian coordinate in specific lattice</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fBravis</span> <span class="o">=</span> <span class="n">fCell</span>
    <span class="n">fInner</span> <span class="o">=</span> <span class="n">listInner</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">fBravis</span><span class="p">,</span><span class="n">fInner</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">result</span>
</div>
<div class="viewcode-block" id="ConvertCartesianToInnerCoord"><a class="viewcode-back" href="../main_struct.html#common_caseutil.ConvertCartesianToInnerCoord">[docs]</a><span class="k">def</span> <span class="nf">ConvertCartesianToInnerCoord</span><span class="p">(</span><span class="n">fCell</span><span class="p">,</span><span class="n">listCart</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert cartesian to inner coordinate in specific lattice</span>

<span class="sd">    :param fCell: a 3x3  ndarray, each row is a vector of lattice axis</span>
<span class="sd">    :param listCart: a list of Cartesian coordinate</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">fBravis</span> <span class="o">=</span> <span class="n">fCell</span>
    <span class="n">fCart</span> <span class="o">=</span> <span class="n">listCart</span>
    
    <span class="n">result</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">fBravis</span><span class="p">),</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">fCart</span><span class="p">))</span> <span class="c"># convert fCart to column vector</span>
    <span class="k">return</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="c"># return normal list from row vector, remove dual list</span>
    
</div>
<div class="viewcode-block" id="f_Latt_IsClinic"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_Latt_IsClinic">[docs]</a><span class="k">def</span> <span class="nf">f_Latt_IsClinic</span><span class="p">(</span><span class="n">listAngle</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Determine whether a cell is monoclinic or tricilinic</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">listAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">listAngle</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">listAngle</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">listAngle</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">&lt;</span><span class="mf">0.01</span><span class="p">):</span>
<span class="c">#Rho</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">dAngle</span> <span class="ow">in</span> <span class="n">listAngle</span><span class="p">:</span>
<span class="c">#Ortho or Hex</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dAngle</span><span class="o">-</span><span class="mf">90.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dAngle</span><span class="o">-</span><span class="mf">120.0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

</div>
<div class="viewcode-block" id="Lattice"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice">[docs]</a><span class="k">class</span> <span class="nc">Lattice</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A basic representation of lattice, all basic number unit in bohr and deg</span>
<span class="sd">    Cartesian vectors follow this: c-axis as [0,0,c] b-c in a plane of axis</span>
<span class="sd">    Members start with &quot;Create&quot; will return a new Lattice object, otherwise itself will change</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">coord_Cartesian</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">coord_Primitive</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">coord_Conventional</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">coord_Raw</span> <span class="o">=</span> <span class="mi">4</span>
    
    <span class="n">coord_Cart</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">coord_Prim</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">coord_Conv</span> <span class="o">=</span> <span class="mi">3</span>
    
    <span class="n">dErrMax</span> <span class="o">=</span> <span class="mf">0.000001</span> <span class="c"># using to &lt;,=,&gt; of float type</span>

    <span class="n">filename_xsd</span> <span class="o">=</span> <span class="s">&quot;lattice.xsd&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># in internal coordinate of primitive cell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span> <span class="o">=</span> <span class="bp">False</span> <span class="c"># in raw mode, raw cell vector will be used to determine atom position. And primitive-conventional conversion will be banned. Don&#39;t change it in other function !</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__RawPrimitiveVector__</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span> <span class="c"># raw cell vector, maybe deviate from autocreate vector like [1,0,0]/[0,1,0] but [/2,/2,0] and [-/2,/2,0]  </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__RawConventionalVector__</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c">#self.PrimitiveCellVector = []</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listFix</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#: list of where atoms are fixed on given direction</span>

    <span class="nd">@classmethod</span>
<div class="viewcode-block" id="Lattice.load_xml"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.load_xml">[docs]</a>    <span class="k">def</span> <span class="nf">load_xml</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Load parameters from a XML file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="n">XMLSerilizer</span><span class="o">.</span><span class="n">load_xml</span><span class="p">(</span><span class="nb">globals</span><span class="p">(),</span><span class="n">cls</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
 </div>
<div class="viewcode-block" id="Lattice.save"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save parameters to a XML file</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">XMLSerilizer</span><span class="o">.</span><span class="n">save_xml</span><span class="p">(</span><span class="n">Lattice</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="n">filename</span><span class="p">)</span>
</div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">IsRaw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return whether Lattice object is operated in raw mode</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">PrimitiveCellVector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Primitive cell vectors</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__RawPrimitiveVector__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__GetPrimitiveCell__</span><span class="p">()</span>
    
    <span class="nd">@property</span>    
    <span class="k">def</span> <span class="nf">ConventionalCellVector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Conventional cell vectors</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__RawConventionalVector__</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ConvertLatticeToCartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">)</span>    

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">Volume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Volume of convetional cell vectors</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span><span class="p">):</span>
            <span class="n">vt</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__RawConventionalVector__</span><span class="p">)</span>
            <span class="c">#print(vt)</span>
            <span class="k">return</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_dot3</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_cross3</span><span class="p">(</span><span class="n">vt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">vt</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">vt</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c">#print(self.fLatticeAngle)</span>
            <span class="n">dCos</span> <span class="o">=</span> <span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="mf">180.0</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">]</span>
            <span class="c">#print(dCos)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">dCos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">dCos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">dCos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">dCos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">dCos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">dCos</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="Lattice.init_fix"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.init_fix">[docs]</a>    <span class="k">def</span> <span class="nf">init_fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">b_fix</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create informations about fix</span>

<span class="sd">        :param b_fix: initialze with True or False</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listFix</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">b_fix</span><span class="p">,</span><span class="n">b_fix</span><span class="p">,</span><span class="n">b_fix</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">]</span>
       </div>
    <span class="k">def</span> <span class="nf">ReadFromABC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nLatticeType</span><span class="p">,</span><span class="n">fLatticeLength</span><span class="p">,</span><span class="n">fLatticeAngle</span><span class="p">,</span><span class="n">unit_length</span><span class="o">=</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="n">unit_angle</span><span class="o">=</span><span class="s">&quot;deg&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">unit_length</span> <span class="o">==</span> <span class="s">&quot;ang&quot;</span> <span class="ow">or</span> <span class="n">unit_length</span> <span class="o">==</span> <span class="s">&quot;angstrom&quot;</span><span class="p">):</span>
            <span class="n">fLatticeLength</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">Ang2Bohr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fLatticeLength</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">unit_angle</span> <span class="o">==</span> <span class="s">&quot;rad&quot;</span><span class="p">):</span>
            <span class="n">fLatticeAngle</span>  <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">constants</span><span class="o">.</span><span class="n">Rad2Deg</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fLatticeAngle</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="n">nLatticeType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span> <span class="o">=</span> <span class="n">fLatticeLength</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span> <span class="o">=</span> <span class="n">fLatticeAngle</span>
        <span class="c">#self.PrimitiveCellVector = self.__GetPrimitiveCell__()</span>
       
        <span class="c">#print(&quot;Before Primitive:&quot;)</span>
        <span class="c">#self.WriteToFile(&quot;&quot;)</span>
        
        <span class="c">#self.__GetLatticeFromPrimitiveCell__()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__GetLatticeFromPrimitiveCellVector__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PrimitiveCellVector</span><span class="p">)</span>
        
        <span class="c">#print(&quot;After Primitive&quot;)</span>
        <span class="c">#self.WriteToFile(&quot;&quot;)</span>
    
<div class="viewcode-block" id="Lattice.ReadFromRawCellVector"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.ReadFromRawCellVector">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFromRawCellVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mBravisConv</span><span class="p">,</span><span class="n">mBravisPrim</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read Lattice object from specified cell vectors</span>
<span class="sd">        Note one may provide BOTH conventional and primitive cell vectors</span>

<span class="sd">        :param mBravisConv: Bravis matrix of the conventional cell</span>
<span class="sd">        :param mBravisPrim: Bravis matrix of the primitive cell, optional; If negelected Conv/Prim are the same.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mBravisPrim</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">mBravisPrim</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mBravisConv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__RawPrimitiveVector__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mBravisPrim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__RawConventionalVector__</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">mBravisConv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bRaw__</span> <span class="o">=</span> <span class="bp">True</span>
<span class="c">#Create lattice length/angle information</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">)</span> <span class="o">=</span> <span class="n">ConvertCartesianToLattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__RawConventionalVector__</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="Lattice.ReadFromPrimitiveCellVector"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.ReadFromPrimitiveCellVector">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFromPrimitiveCellVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mBravis</span><span class="p">,</span><span class="n">nLatticeType</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read Cell from cell vectors and Lattice Type ( If no lattice type is used, original one will be used)</span>
<span class="sd">        Atoms&#39; crystal coordination will not moved ! </span>

<span class="sd">        :param mBravis: Cell vectors</span>
<span class="sd">        :param nLatticeType: The lattice type, if NONE then the nLatticeType stored in the current object is used </span>
<span class="sd">        :param bRaw: If set to true, will not utilize primitive-conventional convertion in the process, and put the mode of Lattice object to raw</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nLatticeType</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="n">nLatticeType</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__GetLatticeFromPrimitiveCellVector__</span><span class="p">(</span><span class="n">mBravis</span><span class="p">)</span>
    
</div>
    <span class="k">def</span> <span class="nf">__GetPrimitiveCell__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        
        <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span>
        <span class="p">(</span><span class="n">aa</span><span class="p">,</span><span class="n">ab</span><span class="p">,</span><span class="n">ac</span><span class="p">)</span><span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">/</span><span class="mf">180.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">]</span>
        <span class="c">#print(a,b,c,aa,ab,ac)</span>
        
        <span class="k">if</span> <span class="p">(</span> <span class="n">aa</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">aa</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ab</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">ac</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="n">ac</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="mf">2.0</span>
        
        <span class="n">listPrim</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">]])</span> <span class="c"># Nothing</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">]])</span> <span class="c"># P cubic</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span> <span class="c"># F</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># I</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">(([</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="o">*</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">]))</span> <span class="c"># H simple</span>
        <span class="n">tx</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">a</span>
        <span class="n">ty</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span><span class="o">/</span><span class="mi">6</span><span class="p">)</span><span class="o">*</span><span class="n">a</span>
        <span class="n">tz</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">((</span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">))</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">a</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">tx</span><span class="p">,</span> <span class="o">-</span><span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="n">tx</span><span class="p">,</span> <span class="o">-</span><span class="n">ty</span><span class="p">,</span> <span class="n">tz</span><span class="p">]])</span> <span class="c">#R (+5)</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">]])</span> <span class="c"># P Tetra</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># I Tetra</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">]])</span> <span class="c"># P Ortho</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">]])</span> <span class="c"># B-center Ortho</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># F Ortho</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="o">-</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="n">b</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># I Ortho</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="p">]])</span> <span class="c"># monoclinic</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">],[</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="mi">0</span><span class="p">],[</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">c</span><span class="o">/</span><span class="mi">2</span><span class="p">]])</span> <span class="c"># B-c mono</span>
        <span class="n">listPrim</span><span class="o">.</span><span class="n">append</span><span class="p">([[</span><span class="n">a</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="n">b</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span><span class="mi">0</span><span class="p">],[</span><span class="n">c</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ab</span><span class="p">),</span>  <span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">))</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ac</span><span class="p">),</span> <span class="n">c</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span>  <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">aa</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ab</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">ac</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">ac</span><span class="p">)]])</span> <span class="c"># Tri</span>
        
        <span class="c">#print(&quot;Primitive Cell: %d&quot; % self.nLatticeType)</span>
        <span class="c">#print(listPrim[self.nLatticeType])</span>
        
        <span class="k">return</span> <span class="n">listPrim</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">__GetLatticeFromPrimitiveCellVector__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mBravis</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get QE-type described ibrav from bravis matrix</span>
<span class="sd">        Note some matrix input here is not from QE and may be in other format!</span>
<span class="sd">        @todo trigonal,monoclinic and triclinic are different in w2k and QE</span>
<span class="sd">        ibrav -5 and -12 is not supported</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#PV = self.PrimitiveCellVector</span>
        <span class="n">PV</span> <span class="o">=</span> <span class="n">mBravis</span>
        <span class="c">#print(PV)</span>
        <span class="n">a0</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c"># for a axis = [a,0,0] cell to minimize non-symmetry influence</span>
        <span class="n">b0</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c0</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">PV</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">PV</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">):</span>
            <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="n">a</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="o">-</span><span class="n">c</span>
        <span class="c">#Calc primitive cell information    </span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">)</span> <span class="o">=</span> <span class="n">ConvertCartesianToLattice</span><span class="p">(</span><span class="n">PV</span><span class="p">)</span>    
        <span class="c">#print(self.fLatticeLength,self.fLatticeAngle)</span>
        <span class="c">#The ibrav has more than 1 unit, need listLatt</span>
        <span class="n">arMulti</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">]</span>
        <span class="n">arNonSpecialAngle</span> <span class="o">=</span> <span class="p">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,</span><span class="mi">14</span><span class="p">]</span> <span class="c"># non-90 or 60 </span>

<span class="c">#If it is monoclinic or triclinic then directly return</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="ow">in</span> <span class="n">arNonSpecialAngle</span> <span class="p">):</span>
            <span class="k">return</span>
        
        <span class="n">listLatt</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">120.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">120.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a0</span><span class="p">,</span><span class="n">a0</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">b</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">c</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">])</span>
        <span class="c">#if ( PV[0][1] != 0 or PV[0][2] != 0 or  PV[1][0] != 0 or PV[1][2] != 0 or PV[2][0] != 0 or PV[2][1] != 0): </span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">False</span><span class="p">):</span>
            <span class="c"># only deal with QE-type monoclinic and triclinic when the bravis matrix is not belong to orthogonal to avoid 0 error</span>
            <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="p">,</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">c</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">180.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])])</span>
            <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">a</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="n">c</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">90.0</span><span class="p">,</span><span class="mf">180.0</span><span class="o">/</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">atan</span><span class="p">(</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">PV</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">listLatt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">)</span>
        
        <span class="c">#if ( self.nLatticeType in arMulti):</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">listLatt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
<span class="c">#If not found, than use direct calculated result, which is already set</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span><span class="c">#Use detected result</span>
           <span class="c"># Indeed, some results can be obtained from direct calculation, but we prefer manually classified ones to avoid inconsistence in some non-sysmmetry-keep optimization ( like BFGS in Espresso)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span> <span class="o">=</span> <span class="n">listLatt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span> <span class="o">=</span> <span class="n">listLatt</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span><span class="p">][</span><span class="mi">3</span><span class="p">:</span><span class="mi">6</span><span class="p">]</span>
 
        

    <span class="k">def</span> <span class="nf">__ConvertCoordinate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nIn</span><span class="p">,</span><span class="n">nOut</span><span class="p">,</span><span class="n">arPos</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Convert a kind of coordinate to another</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mConventionalCellT</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ConventionalCellVector</span><span class="p">)</span>
        <span class="n">mPrimitiveCellT</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PrimitiveCellVector</span><span class="p">)</span>
        <span class="c">#mRawCellT = lu.f_Matrix_transpose(self.__RawCellVector__)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nIn</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">):</span>
            <span class="n">mPosC</span> <span class="o">=</span>  <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mConventionalCellT</span> <span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">arPos</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">nIn</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">):</span>
            <span class="n">mPosC</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mPrimitiveCellT</span> <span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">arPos</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">nIn</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">):</span>
            <span class="n">mPosC</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">arPos</span><span class="p">])</span>
<span class="c">#        elif ( nIn == Lattice.coord_Raw):</span>
<span class="c">#            mPosC = lu.f_Matrix_dot(mRawCellT,lu.f_Matrix_transpose([arPos]))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Unsupported input coordinate type: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nIn</span><span class="p">))</span>
        <span class="c">#print(&quot;arPos: &quot;,arPos)</span>
        <span class="c">#print(&quot;mPosC: &quot;,mPosC)    </span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nOut</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span> <span class="p">):</span>
            <span class="n">mOut</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">mConventionalCellT</span><span class="p">)</span> <span class="p">,</span> <span class="n">mPosC</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">nOut</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">):</span>
            <span class="n">mOut</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">mPrimitiveCellT</span><span class="p">)</span> <span class="p">,</span> <span class="n">mPosC</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">nOut</span> <span class="o">==</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">):</span>
            <span class="n">mOut</span> <span class="o">=</span> <span class="n">mPosC</span>
<span class="c">#        elif ( nOut == Lattice.coord_Raw):</span>
<span class="c">#            mOut = lu.f_Matrix_dot( lu.f_List_inv3(mRawCellT) , mPosC)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Unsupported output coordinate type: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">nIn</span><span class="p">))</span>
        
        <span class="c">#print(&quot;mOut&quot;,lu.f_Matrix_transpose(mOut)[0])</span>
        <span class="k">return</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">mOut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>        
    
<div class="viewcode-block" id="Lattice.AddAtom"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.AddAtom">[docs]</a>    <span class="k">def</span> <span class="nf">AddAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">listPos</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="n">latt</span><span class="o">=</span><span class="s">&quot;primitive&quot;</span><span class="p">,</span><span class="n">a</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a atom list by Cartesian Coordinate or Crystal Coordinate, indicated by unit_length</span>
<span class="sd">        Note: please be cautious with latt=&quot;alat&quot;, because &quot;a&quot; is not fixed during cell shape change.</span>
<span class="sd">        </span>
<span class="sd">        :param listCart: in form of  [Element name,x,y,z]</span>
<span class="sd">        :param unit: indicate type of xyz : bohr, ang/angstrom, cry/crys/crystal, alat</span>
<span class="sd">        :param latt: indicate which cell xyz is related to : primtive/conventional ( only affect when unit is crystal ), raw ( stored cell vectors )</span>
<span class="sd">        :param a: the length of a in unit of Bohr. Default is the fLatticeLength (which is the first lattice vector if bRaw, otherwise conventional lattice vector).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;bohr&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAtomFromCartesian</span><span class="p">(</span><span class="n">listPos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;ang&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;angstrom&quot;</span><span class="p">):</span>
            <span class="n">listPos2</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="n">aPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">Ang2Bohr</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">aPos</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]]</span> <span class="k">for</span> <span class="n">aPos</span> <span class="ow">in</span> <span class="n">listPos</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAtomFromCartesian</span><span class="p">(</span><span class="n">listPos2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;alat&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">listPos2</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span> <span class="n">aPos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">a</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">aPos</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]]</span> <span class="k">for</span> <span class="n">aPos</span> <span class="ow">in</span> <span class="n">listPos</span> <span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAtomFromCartesian</span><span class="p">(</span><span class="n">listPos2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;cry&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;crys&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span><span class="s">&quot;crystal&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;internal&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;primitive&quot;</span> <span class="ow">or</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;prim&quot;</span> <span class="p">):</span><span class="c">#internal coordinate of Primitive Cell</span>
                <span class="k">for</span> <span class="n">fCoord</span> <span class="ow">in</span> <span class="n">listPos</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fCoord</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="p">(</span><span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;normal&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">latt</span><span class="o">==</span><span class="s">&quot;convetional&quot;</span><span class="p">)):</span> <span class="c">#internal coordinate of Normal cell</span>
                <span class="c">#ConventionalCell = numpy.matrix(ConvertLatticeToCartesian(self.fLatticeLength,self.fLatticeLength))</span>
                <span class="k">for</span> <span class="n">fCoord</span> <span class="ow">in</span> <span class="n">listPos</span><span class="p">:</span>
                    <span class="c">#self.listAtom.append([fCoord[0]]+self.__GetPrimitiveCoordFromNormalCoord__(fCoord[1:4]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">fCoord</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,</span><span class="n">fCoord</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>
                <span class="c">#self.AddAtomFromCartesian([fCoord[0]]+ConventionalCell.T*numpy.matrix(fCoord[1:4]).tolist())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;AddAtom: Unrecognized mode &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>                    
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;AddAtom: Unrecognized mode &#39;</span><span class="si">%s</span><span class="s">&#39;&quot;</span> <span class="o">%</span> <span class="n">unit</span><span class="p">)</span>
                             

    </div>
<div class="viewcode-block" id="Lattice.AddAtomFromCartesian"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.AddAtomFromCartesian">[docs]</a>    <span class="k">def</span> <span class="nf">AddAtomFromCartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">listCart</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add a atom list by Cartesian Coordinate</span>

<span class="sd">        :param listCard: a list of atom positions, each atom positions must be in the format [&#39;Name&#39;,x,y,z]</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">fCart</span> <span class="ow">in</span> <span class="n">listCart</span><span class="p">:</span>
            <span class="n">fInner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Prim</span><span class="p">,</span> <span class="n">fCart</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
            <span class="c">#print(fCart,fInner)</span>
            <span class="c">#fInner = (numpy.matrix(fPrim).I*numpy.matrix(fCart[1:4]).T).T.tolist()</span>
            <span class="c">#fInner = ConvertCartesianToInnerCoord(fPrim,fCart[1:4])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="p">[</span><span class="n">fCart</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="n">fInner</span> <span class="p">)</span>
         </div>
<div class="viewcode-block" id="Lattice.CorrectError"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.CorrectError">[docs]</a>    <span class="k">def</span> <span class="nf">CorrectError</span> <span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Set some standard fractional coordinate (like 1/3 ) to their exact value to beautify the output</span>
<span class="sd">        Example : 0.6666663562472133 to 0.6666666666667, 0.249999998232 to 0.25</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_CorrectFloat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_CorrectFloat</span><span class="p">(</span><span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>            
                
</div>
<div class="viewcode-block" id="Lattice.ShowSummary"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.ShowSummary">[docs]</a>    <span class="k">def</span> <span class="nf">ShowSummary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Write cell information to specific file or screen</span>

<span class="sd">        :param stFileName: if set to None, set print to screen</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stFileName</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">fOut</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fOut</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span>
            
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Summary of cell:&quot;</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">PrimitiveCellVector</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="n">aAtom</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="nb">file</span><span class="o">=</span><span class="n">fOut</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stFileName</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">fOut</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            </div>
    <span class="nd">@property</span>        
    <span class="k">def</span> <span class="nf">listAtomInConvCell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        List all atom in the conventional cell ( by conventional cell crystal coordinate )</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="c">#        listAtomNormal = []</span>
<span class="c">#        for aAtom in self.listAtom:</span>
<span class="c">#            for a1 in range(-1,2): #Extend to 3x3 primitive cell and list all atom in the normal cell</span>
<span class="c">#                for a2 in range(-1,2):</span>
<span class="c">#                    for a3 in range(-1,2):</span>
<span class="c">#                        #arPos = self.__GetNormalCoordFromPrimitiveCoord__([aAtom[1]+a1,aAtom[2]+a2,aAtom[3]+a3])</span>
<span class="c">#                        arPos = self.__ConvertCoordinate__(Lattice.coord_Primitive,Lattice.coord_Conventional,[aAtom[1]+a1,aAtom[2]+a2,aAtom[3]+a3])</span>
<span class="c">#                        if ( arPos[0] &lt; 1 and arPos[0] &gt;= 0 and arPos[1] &lt; 1 and arPos[1] &gt;= 0 and arPos[2] &lt; 1 and arPos[2] &gt;=0):</span>
<span class="c">#                            listAtomNormal.append([aAtom[0]] + f_CorrectFloat(arPos))</span>
<span class="c">#        return listAtomNormal</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetAtomList</span><span class="p">(</span><span class="s">&quot;conv&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>
    
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">listAtomCartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        list all atom in Cartesian Coordinate</span>
<span class="sd">        &#39;&#39;&#39;</span>
<span class="c">#        listAtom = []</span>
<span class="c">#        for aAtom in self.listAtom:</span>
<span class="c">#            arPos = self.__ConvertCoordinate__(Lattice.coord_Primitive, Lattice.coord_Cartesian, aAtom[1:4])</span>
<span class="c">#            listAtom.append([aAtom[0]]+arPos)</span>
<span class="c">#        return listAtom</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetAtomList</span><span class="p">()</span>
    
<div class="viewcode-block" id="Lattice.GetAtomList"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.GetAtomList">[docs]</a>    <span class="k">def</span> <span class="nf">GetAtomList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">unit</span><span class="o">=</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="n">latt</span><span class="o">=</span><span class="s">&quot;primitive&quot;</span><span class="p">,</span><span class="n">extend</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get a list of atom in some representaion</span>

<span class="sd">        :param unit: the unit of coordinate, including bohr,ang,alat,primitive,conventional</span>
<span class="sd">        :param latt: the atom in whole convetional cell or one primitive cell</span>
<span class="sd">        :param extend: the lattice will be examed </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">listAtom1</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#Get atoms</span>
        
        <span class="n">bPrim</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c">#fMin = [ -x for x in extend] # lower boundary</span>
        <span class="c">#fMax = [ x+1 for x in extend]    #upper boundary</span>
        <span class="n">fMin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">fMax</span> <span class="o">=</span> <span class="mi">1</span>
           
        <span class="k">if</span> <span class="p">(</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;normal&quot;</span> <span class="ow">or</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;conv&quot;</span> <span class="ow">or</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;convetional&quot;</span><span class="p">):</span>
            <span class="c">#extend = [ x * 2 + 1 for x in extend]</span>
            <span class="n">bPrim</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;primitive&quot;</span> <span class="ow">or</span> <span class="n">latt</span> <span class="o">==</span> <span class="s">&quot;prim&quot;</span><span class="p">):</span>
            <span class="k">pass</span> 
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">&quot;Unknown cell type: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">latt</span><span class="p">)</span>
        
        <span class="n">arConvTrans</span> <span class="o">=</span> <span class="p">[[],[],[]]</span>
        <span class="n">listAtom2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">bPrim</span> <span class="p">):</span> <span class="c"># get convtional cell transitional move vector ( [a,b,c], in unit of primitive cell )</span>
            <span class="n">arConvTrans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
            <span class="n">arConvTrans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">])</span>
            <span class="n">arConvTrans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,[</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">0.0</span><span class="p">,</span><span class="mf">1.0</span><span class="p">])</span>
            <span class="c">#print(arConvTrans)</span>
            <span class="c">#Get atoms in 1x1x1 conv cell</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span> <span class="c">#Extend to 3x3 primitive cell and list all atom in the conventional cell</span>
                    <span class="k">for</span> <span class="n">a2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">a3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                            <span class="n">arPos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,[</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a1</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">a2</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">a3</span><span class="p">])</span>
                            <span class="n">arPos</span> <span class="o">=</span> <span class="n">f_CorrectFloat</span><span class="p">(</span><span class="n">arPos</span><span class="p">)</span>
                            <span class="c">#print(arPos)</span>
                            <span class="n">bInCell</span> <span class="o">=</span> <span class="bp">True</span>
                            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                                <span class="k">if</span> <span class="p">(</span> <span class="n">arPos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">fMax</span> <span class="ow">or</span> <span class="n">arPos</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">fMin</span> <span class="p">):</span>
                                    <span class="c">#print(arPos)</span>
                                    <span class="n">bInCell</span> <span class="o">=</span> <span class="bp">False</span>
                                    <span class="k">break</span>
                            <span class="k">if</span> <span class="p">(</span> <span class="n">bInCell</span><span class="p">):</span>
                                <span class="c">#print(a1,a2,a3)</span>
                                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a1</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">a2</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">a3</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">listAtom2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span>    
        <span class="c">#print(listAtom2)</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom2</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extend</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">extend</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c">#Extend to 3x3 primitive cell and list all atom in the conventional cell</span>
                <span class="k">for</span> <span class="n">a2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extend</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">extend</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">a3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">extend</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span><span class="n">extend</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                        <span class="c">#arPos = self.__GetNormalCoordFromPrimitiveCoord__([aAtom[1]+a1,aAtom[2]+a2,aAtom[3]+a3])</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">bPrim</span> <span class="p">):</span>
                            <span class="n">listAtom1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">a1</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">a2</span><span class="p">,</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="n">a3</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">arPos</span> <span class="o">=</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
                            <span class="c">#arPos = lu.f_List_Op_List(arPos, &quot;+&quot;, lu.f_List_Op_Scalar(arConvTrans[0], &quot;*&quot;, a1))</span>
                            <span class="c">#arPos = lu.f_List_Op_List(arPos, &quot;+&quot;, lu.f_List_Op_Scalar(arConvTrans[1], &quot;*&quot;, a3))</span>
                            <span class="c">#arPos = lu.f_List_Op_List(arPos, &quot;+&quot;, lu.f_List_Op_Scalar(arConvTrans[2], &quot;*&quot;, a3))</span>
                            <span class="n">arPos</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">arPos</span><span class="p">,</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">arConvTrans</span><span class="p">),[[</span><span class="n">a1</span><span class="p">],[</span><span class="n">a2</span><span class="p">],[</span><span class="n">a3</span><span class="p">]]))[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">listAtom1</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">arPos</span><span class="p">)</span>
                            <span class="k">continue</span>
        
        <span class="c">#Convert to coordinate</span>
        <span class="n">nIn</span> <span class="o">=</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span>
        <span class="n">listAtom2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;bohr&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom1</span><span class="p">:</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">nIn</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">,</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;ang&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;angstrom&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom1</span><span class="p">:</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">constants</span><span class="o">.</span><span class="n">Bohr2Ang</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">nIn</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">,</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;alat&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom1</span><span class="p">:</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="n">x</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">nIn</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">,</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])])</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;primitive&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;prim&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom1</span><span class="p">:</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span> <span class="n">f_CorrectFloat</span><span class="p">(</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;conventional&quot;</span> <span class="ow">or</span> <span class="n">unit</span> <span class="o">==</span> <span class="s">&quot;conv&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom1</span><span class="p">:</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="n">f_CorrectFloat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">nIn</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])))</span>
<span class="c">#These unit should not be supported here</span>
<span class="c">#       elif (unit == &quot;crystal&quot; or unit == &quot;crys&quot;):</span>
<span class="c">#           listAtom2 = listAtom1</span>
        
        <span class="k">return</span> <span class="n">listAtom2</span>            
            
                          </div>
<div class="viewcode-block" id="Lattice.MoveCell"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.MoveCell">[docs]</a>    <span class="k">def</span> <span class="nf">MoveCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">vDistance</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Move Cell by a specific vector</span>

<span class="sd">        :param vDistance: The vector to move, unit of crystal coordinate of conventional vector</span>
<span class="sd">        :param nAtomIndex: which atom to move, if not set vector will be used, vector will be neglected otherwise</span>
<span class="sd">        :param nNewPos: Which position the atom will be moved to</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c"># Convert conventional crystal coord to primitive crystal coord</span>
        <span class="c">#vMove = self.__GetPrimitiveCoordFromNormalCoord__(vDistance)</span>
        <span class="n">vMove</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Primitive</span><span class="p">,</span> <span class="n">vDistance</span><span class="p">)</span>
        
        <span class="c">#reversely move  atom = move cell</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
            <span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="n">vMove</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">aAtom</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-=</span> <span class="n">vMove</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-=</span> <span class="n">vMove</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            
            </div>
<div class="viewcode-block" id="Lattice.ExpandCell"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.ExpandCell">[docs]</a>    <span class="k">def</span> <span class="nf">ExpandCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stRefAxis</span><span class="o">=</span><span class="s">&quot;001&quot;</span><span class="p">,</span><span class="n">nCell</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">nVacuum</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Then extended Cell x times plus vacuum y times of original cell.</span>
<span class="sd">        Some high symmertry may broke for this reason. </span>

<span class="sd">        :param stRefAxis: the axis to extended ( always postive ), only 100,010 and 001 is supported</span>
<span class="sd">        :param nCell: the number of cell layer</span>
<span class="sd">        :param nVacuum: the length of vacuum layer ( relative to cell length )</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">nAxis</span> <span class="o">=</span> <span class="n">stRefAxis</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s">&quot;1&quot;</span><span class="p">)</span>
        <span class="c">#Get All atom and extended them</span>
        <span class="c">#Duplicate all atom and store in cartesian coordinate</span>
        <span class="n">listAtom2</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">nCell</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtomInConvCell</span><span class="p">:</span>
                <span class="n">aAtom2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aAtom</span><span class="p">)</span>
                <span class="n">aAtom2</span><span class="p">[</span><span class="n">nAxis</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">i</span>
                <span class="n">listAtom2</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">__ConvertCoordinate__</span><span class="p">(</span><span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Conventional</span><span class="p">,</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">coord_Cartesian</span><span class="p">,</span><span class="n">aAtom2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>   
        <span class="c"># Deal with symmetry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="n">nAxis</span><span class="p">]</span> <span class="o">*=</span> <span class="p">(</span><span class="n">nCell</span><span class="o">+</span><span class="n">nVacuum</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span> <span class="c">#Cubic</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="mi">6</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">==</span> <span class="mi">6</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">==</span> <span class="mi">7</span><span class="p">):</span> <span class="c">#</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nAxis</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="c">#Clear all atoms and store new atoms</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">AddAtomFromCartesian</span><span class="p">(</span><span class="n">listAtom2</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">CorrectError</span><span class="p">()</span>
        
        
        
            </div>
<div class="viewcode-block" id="Lattice.RotateCell"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.RotateCell">[docs]</a>    <span class="k">def</span> <span class="nf">RotateCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">arRefPoint</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">stRefAxis</span><span class="o">=</span><span class="s">&quot;001&quot;</span><span class="p">,</span><span class="n">stNewAxis</span><span class="o">=</span><span class="s">&quot;001&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Transform a cell to another orientation ( for surface SLAB )</span>
<span class="sd">        Fix ref point, rotate ref axis (a or b or c) to new orientation, xyz axis will be rotated as well</span>
<span class="sd">        Equally = all atom rotate reverse</span>
<span class="sd">        </span>
<span class="sd">        Note: the rotation axis is vertical to the plane of old ref axis and new axis</span>
<span class="sd">        All action is do in conventional cell. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">arCell</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
        <span class="n">mCellT</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">arCell</span><span class="p">)</span>
        <span class="c">#get new axis from miller index</span>
        <span class="n">arOldAxis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stRefAxis</span><span class="p">]</span>
        <span class="n">vOldAxis</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mCellT</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">arOldAxis</span><span class="p">])))[</span><span class="mi">0</span><span class="p">]</span>   
        <span class="n">arNewAxis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">stNewAxis</span><span class="p">]</span>
        <span class="n">vNewAxis</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mCellT</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">arNewAxis</span><span class="p">])))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c">#Get rotation matrix ( reversed, as it will affect atom )</span>
        <span class="n">vRot</span> <span class="o">=</span>  <span class="n">lu</span><span class="o">.</span><span class="n">f_List_cross3</span><span class="p">(</span><span class="n">vOldAxis</span><span class="p">,</span> <span class="n">vNewAxis</span><span class="p">)</span>
        <span class="n">vRot</span> <span class="o">=</span> <span class="n">vRot</span> <span class="o">/</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">vRot</span><span class="p">)</span> <span class="c"># shoulde be unit vector</span>
        <span class="n">nAngle</span> <span class="o">=</span> <span class="o">-</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_angle3</span><span class="p">(</span><span class="n">vOldAxis</span><span class="p">,</span><span class="n">vNewAxis</span><span class="p">)</span>
        <span class="n">mRot</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">cosA</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">nAngle</span><span class="p">)</span>
        <span class="n">sinA</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">nAngle</span><span class="p">)</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span> <span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">sinA</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">mRot</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span>  <span class="n">cosA</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">cosA</span><span class="p">)</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">vRot</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

        <span class="c">#verify if rotation is right ( for old axis )</span>
        <span class="n">vOldCalc</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mRot</span><span class="p">,</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">vNewAxis</span><span class="p">])))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Result verify:&quot;</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">vOldCalc</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">vOldAxis</span><span class="p">)</span>
        <span class="c">#Do rotate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nLatticeType</span> <span class="o">=</span> <span class="mi">14</span>
        <span class="n">listAtom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtomInConvCell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># clear atom list</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom</span><span class="p">:</span>
            <span class="n">aAtom2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aAtom</span><span class="p">)</span>
            <span class="n">aAtom2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">mRot</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">aAtom2</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]])))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">([</span><span class="n">aAtom2</span><span class="p">],</span> <span class="s">&quot;crystal&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">CorrectError</span><span class="p">()</span>
    </div>
<div class="viewcode-block" id="Lattice.ChangeCell"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.ChangeCell">[docs]</a>    <span class="k">def</span> <span class="nf">ChangeCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stMode</span><span class="o">=</span><span class="s">&quot;c:1&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Change a specific Lattice object with specific method</span>
<span class="sd">        Note: any change on crystal axis will not affect the internal coordinate of atom</span>
<span class="sd">        In clayer mode, if there exist a distance much larger than others, it will be treated as Slab vacuum and not extended</span>

<span class="sd">        :params stMode: the way to change lattice, &quot;c&quot; and &quot;tmdc&quot; is supported. in format &quot;mode:para;mode:para&quot;</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">listMode</span> <span class="o">=</span> <span class="n">f_Split_EnumerateRangeString</span><span class="p">(</span><span class="n">stMode</span><span class="p">)</span>
        <span class="n">aMode</span> <span class="o">=</span> <span class="n">listMode</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="c"># only first mode is useds</span>
        <span class="k">for</span> <span class="n">aNamePara</span> <span class="ow">in</span> <span class="n">aMode</span><span class="p">:</span>
            <span class="n">stName</span> <span class="o">=</span> <span class="n">aNamePara</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">aPara</span> <span class="o">=</span> <span class="n">aNamePara</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">stName</span> <span class="o">==</span> <span class="s">&quot;c&quot;</span> <span class="p">):</span> <span class="c">#modify c axis</span>
                <span class="n">aPara</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">aPara</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aPara</span>
            <span class="k">elif</span> <span class="p">(</span> <span class="n">stName</span> <span class="o">==</span> <span class="s">&quot;tmdc&quot;</span><span class="p">):</span> <span class="c"># modify c axis while keep M-F distance in c axis</span>
                <span class="n">aPara</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">aPara</span><span class="p">)</span>
                <span class="n">listAtom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtomInConvCell</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="n">aPara</span>
                <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom</span><span class="p">:</span> <span class="c"># test whether in 0.25 part or 0.75 part, and keep distance</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span> <span class="mf">0.75</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="mf">0.25</span><span class="p">)</span>  <span class="p">):</span>
                        <span class="n">nRef</span> <span class="o">=</span> <span class="mf">0.75</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nRef</span> <span class="o">=</span> <span class="mf">0.25</span>
                        
                    <span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">nRef</span><span class="p">)</span><span class="o">/</span><span class="n">aPara</span><span class="o">+</span><span class="n">nRef</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">([</span><span class="n">aAtom</span><span class="p">],</span> <span class="s">&quot;internal&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">stName</span> <span class="o">==</span> <span class="s">&quot;clayer&quot;</span><span class="p">):</span> <span class="c">#along c axis, modify distance between layers while keep all non-vdw bond ( detected by bond length ) not change.</span>
                <span class="n">aPara</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">aPara</span><span class="p">)</span>
                <span class="n">listAtom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetAtomList</span><span class="p">(</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>

                <span class="c">#self.listAtom = []</span>
                <span class="c">#self.fLatticeLength[2] *= aPara</span>
                <span class="c"># detect all layer ref point </span>
                <span class="c"># note the layer near c=0 is not moved at all</span>
                <span class="c">#generate atom layer    </span>
                <span class="n">listLayer</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetLayerAtom</span><span class="p">()</span>
                <span class="n">listDistance</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">listDistance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listLayer</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">listLayer</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                <span class="c">#last -&gt; first</span>
                <span class="n">listDistance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listLayer</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">listLayer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
                
                <span class="n">listCAdd</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listDistance</span><span class="p">)):</span>
                    <span class="n">listCAdd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listCAdd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">listDistance</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    
                <span class="c">#Create new structure</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">listCAdd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">aPara</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c">#ignore slab vacuum </span>
                <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listDistance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">listDistance</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">listDistance</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">):</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Slab detected, the vacuum layer distance won&#39;t change.&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">fLatticeLength</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="n">listCAdd</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">listCAdd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">aPara</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                
                <span class="c">#print(listLayer)</span>
                <span class="c">#print(listCAdd)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">aLayer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listLayer</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">listAtomLayer</span> <span class="ow">in</span> <span class="n">aLayer</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">aAtom2</span> <span class="ow">in</span> <span class="n">listAtomLayer</span><span class="p">:</span>
                            <span class="n">aAtom</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aAtom2</span><span class="p">)</span>
                            <span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">listCAdd</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">aPara</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">([</span><span class="n">aAtom</span><span class="p">],</span> <span class="s">&quot;bohr&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Unsupported method to change cell!&quot;</span>
</div>
<div class="viewcode-block" id="Lattice.GetLayerAtom"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.GetLayerAtom">[docs]</a>    <span class="k">def</span> <span class="nf">GetLayerAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dThreshold</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get atom layer along c axis</span>

<span class="sd">        :param dThreshold: The minimum distance between 2 layer. Auto detect if &lt; 0. For example, all atom in range of 4 bohr is treated as same atom layer ( van der Waals ). For a ionic crystal, it should less than 0.1. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#detect whether the slab is suggested by arrange all atom along c axis</span>
        <span class="c">#sort atom by c axis</span>
        <span class="n">listTmp</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span><span class="n">i</span><span class="p">,</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">GetAtomList</span><span class="p">(</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">))]</span>
        <span class="n">listTmp</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">listAtom</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">listTmp</span><span class="p">]</span>
        <span class="n">listAtomLayer</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c">#print(listAtom)</span>
        
        <span class="c">#print(&quot;there are %d / %d atom in a cell&quot; % (len(listAtom),len(result.listAtom)))</span>
        <span class="c">#find can distance be arraged</span>
        <span class="n">listDistance</span> <span class="o">=</span> <span class="p">[]</span> <span class="c"># the distance between different atom layer </span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listAtom</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">listDistance</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listAtom</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">listAtom</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">listDistance</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listDistance</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="s">&quot;Only 1 atom in cell, seems not a suitable cell.&quot;</span>
        <span class="n">dThresholdGuess</span> <span class="o">=</span> <span class="n">listDistance</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.9</span>
        <span class="c">#print(listDistance)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listDistance</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">listDistance</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="mf">1.5</span> <span class="o">&lt;</span> <span class="n">listDistance</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">and</span> <span class="n">listDistance</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">dErrMax</span><span class="p">):</span> <span class="c"># too large difference between atom distance, means there may be physical split</span>
                <span class="n">dThresholdGuess</span> <span class="o">=</span> <span class="n">listDistance</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.99</span>
                <span class="c">#break</span>
        
        <span class="c">#print(&quot;Layer distance: &quot;, listDistance)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Detected layer split distance: </span><span class="si">%f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">dThresholdGuess</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">dThreshold</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span><span class="c"># use detected</span>
            <span class="n">dThreshold</span> <span class="o">=</span> <span class="n">dThresholdGuess</span>
            
        <span class="c">#generate atom layer    </span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listAtomLayer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">listAtomLayer</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">listAtomLayer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">):</span>
                    <span class="n">listAtomLayer</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">listAtomLayer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aAtom</span><span class="p">)</span>

        <span class="c">#generate layer by threshold</span>
        <span class="n">listLayer</span> <span class="o">=</span> <span class="p">[]</span>    
        <span class="k">for</span> <span class="n">aAtomLayer</span> <span class="ow">in</span> <span class="n">listAtomLayer</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">listLayer</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtomLayer</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">aAtomLayer</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">listLayer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">dThreshold</span><span class="p">):</span>
                    <span class="c">#if ( len(listLayer[-1]) != nUnitLayer   ):</span>
                        <span class="c">#print(&quot;Specific unit layer is %n atom layer but %n is found by threshold.&quot; % (nUnitLayer,len(listLayer[-1])))</span>
                    <span class="n">listLayer</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtomLayer</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">listLayer</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">aAtomLayer</span><span class="p">)</span>
                      
        <span class="k">return</span> <span class="n">listLayer</span>              
                </div>
<div class="viewcode-block" id="Lattice.CreateSlab"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.CreateSlab">[docs]</a>    <span class="k">def</span> <span class="nf">CreateSlab</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">dThreshold</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">nLatt</span> <span class="o">=</span> <span class="mi">7</span> <span class="p">,</span> <span class="n">nVacuum</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">nFix</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">nShift</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Slice a n-layer slab from bulk cell with v layer vacuum along c axis. The atoms will be placed in the middle of the cell.</span>
<span class="sd">        A layer ( Unit layer ) is a combination of continuious atom layer. An atom layer is all atom in same c internal coordinate.</span>
<span class="sd">        Unit layer doesn&#39;t require to be same between each two.</span>
<span class="sd">        For example, MoS2 is a layer structure, and a layer contains S-Mo-S, 3 atom layers</span>
<span class="sd">        In AB stack, A is both an atom layer and an unit layer. B is another.</span>
<span class="sd">        repeat 5 times will create a A B A B A slab. Shift = 1 create B A B A B slab.</span>

<span class="sd">        :param nUnitLayer: the mono atom layer count in one unit layer in this manipulation. ( not used currently)</span>
<span class="sd">        :param nLatt: the layer counts of unit layer.</span>
<span class="sd">        :param nVacuum: the layer of vacuum.</span>
<span class="sd">        :param nFix: the layer of atom never move ; the fixed indexs will be returned as return value</span>
<span class="sd">        :param nShift: the start layer, counting from  </span>
<span class="sd">        :param dThreshold: The minimum distance between 2 layer. Auto detect if &lt; 0. For example, all atom in range of 4 bohr is treated as same atom layer ( van der Waals ). For a ionic crystal, it should less than 0.1. </span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
         
        <span class="c">#get atom in in layer listLayer-&gt;AtomLayer -&gt; Atom</span>
        <span class="n">listLayer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetLayerAtom</span><span class="p">(</span><span class="n">dThreshold</span><span class="p">)</span>
        
        <span class="k">print</span><span class="p">(</span><span class="s">&quot;Program detected layer:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">aLayer</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listLayer</span><span class="p">):</span>
            <span class="n">stInfo</span> <span class="o">=</span> <span class="s">&quot;Layer </span><span class="si">%d</span><span class="s">: &quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">aAtomLayer</span> <span class="ow">in</span> <span class="n">aLayer</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">aAtomLayer</span><span class="p">:</span>
                    <span class="n">stInfo</span> <span class="o">+=</span> <span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s">&quot; &quot;</span>
            <span class="k">print</span><span class="p">(</span><span class="n">stInfo</span><span class="p">)</span>
        

        
        <span class="c">#Calculate the maxium supercell along c axis contained in the slab; rounded celing</span>
        <span class="n">nCmax</span> <span class="o">=</span> <span class="p">(</span><span class="n">nLatt</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="c">#record cell vector to move atom</span>
        <span class="n">listVector</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
        <span class="c">#print(listVector)</span>
        <span class="c">#Expand to minium supercell with 1 more layer vacuum to add residual atoms</span>
        <span class="n">result</span><span class="o">.</span><span class="n">ExpandCell</span><span class="p">(</span><span class="s">&quot;001&quot;</span><span class="p">,</span><span class="n">nCmax</span><span class="p">,</span><span class="n">nVacuum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c">#print(result.fLatticeLength)</span>
        
        <span class="c">#Those step is useless for atom should be sorted in slab</span>
        <span class="n">result</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span> 
        
        
        <span class="c">#Add Atoms</span>
        <span class="n">i0</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nAtomCount</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">listFix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="n">nLatt</span><span class="p">):</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i0</span> <span class="o">+</span> <span class="n">nShift</span> <span class="c"># layer number is relative to i</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="n">i</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">listLayer</span><span class="p">)</span>
            <span class="n">bFix</span> <span class="o">=</span> <span class="p">(</span> <span class="n">i0</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">nLatt</span><span class="o">-</span><span class="n">nFix</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>  <span class="ow">and</span> <span class="n">i0</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">nLatt</span><span class="o">+</span><span class="n">nFix</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>  <span class="p">)</span> <span class="c"># fix count is relative to i0</span>
            <span class="k">for</span> <span class="n">aAtomLayer</span> <span class="ow">in</span> <span class="n">listLayer</span><span class="p">[</span><span class="n">i2</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">aAtomLayer</span><span class="p">:</span>
                    <span class="n">aAtom2</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">aAtom</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                        <span class="n">aAtom2</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">listVector</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">*</span> <span class="n">nC</span>
                    <span class="n">result</span><span class="o">.</span><span class="n">AddAtom</span><span class="p">([</span><span class="n">aAtom2</span><span class="p">],</span> <span class="s">&quot;bohr&quot;</span><span class="p">,</span> <span class="s">&quot;conv&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">bFix</span><span class="p">):</span>
                        <span class="n">listFix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nAtomCount</span><span class="p">)</span>
                    <span class="n">nAtomCount</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i0</span> <span class="o">+=</span> <span class="mi">1</span>
            
        <span class="c">#print(result.listAtom)</span>
        
        <span class="c">#Move atoms to centre of c axis</span>
        <span class="c">#Due to a slab model can never be a complex lattice, primitive cell and c axis can be directly used</span>
        <span class="c">#Only do when Vacuum layer &gt; 0</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nVacuum</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">listC</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">listAtom</span><span class="p">]</span>
            <span class="n">fMove</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">listC</span><span class="p">)</span><span class="o">+</span><span class="nb">min</span><span class="p">(</span><span class="n">listC</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
            <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
                <span class="n">aAtom</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">fMove</span>
        
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span><span class="n">listFix</span>
            </div>
<div class="viewcode-block" id="Lattice.CreateSurfCell"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.CreateSurfCell">[docs]</a>    <span class="k">def</span> <span class="nf">CreateSurfCell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stRefAxis</span><span class="o">=</span><span class="s">&quot;001&quot;</span><span class="p">,</span><span class="n">dRot</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">mRot</span><span class="o">=</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Slice a cell that have a plance perpendicular to specifc stRefAxis ( for surface model )</span>
<span class="sd">        The input miller index should be simlified, like 002 may cause unexpected result</span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="n">vRef</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">stRefAxis</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">stRefAxis</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">stRefAxis</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
            
        <span class="c">#Alogrithm error</span>
        <span class="c">#Get new axis</span>
        <span class="c">#listAns = f_SolveCross(vRef[0],vRef[1],vRef[2])</span>
        <span class="c">#if there is [1,x,0] and [y,1,0], keep it if it is among the lowest</span>
        <span class="c">#nLowest = listAns[0][0]</span>
        <span class="c">#ans = None</span>
        <span class="c">#for aAns in listAns:</span>
        <span class="c">#    if ( aAns[0] == nLowest ):</span>
        <span class="c">#        if ( aAns[1][0] == 1 and aAns[1][4] == 1 ):</span>
        <span class="c">#            ans = aAns[1]</span>
        <span class="c">#    else:</span>
        <span class="c">#        break</span>
        <span class="c">#</span>
        <span class="c">#if ( ans == None):</span>
        <span class="c">#    ans = listAns[0][1]</span>
        
        <span class="n">AxisInt</span> <span class="o">=</span> <span class="n">f_GetSurfaceFromMiller</span><span class="p">(</span><span class="n">vRef</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">)</span>
        
        <span class="c">#AxisInt = [[],[],[]] # new axis ,bases are old axis</span>
        <span class="c">#AxisInt[0] = ans[0:3]</span>
        <span class="c">#AxisInt[1] = ans[3:6]</span>
        <span class="c">#AxisInt[2] = copy.deepcopy(vRef)</span>

        <span class="c">#Rotate</span>
        <span class="c">#dRot = dRot * math.pi / 180</span>
        <span class="c">#mRot = f_RotateMatrix(dRot,AxisInt[2])</span>
        <span class="c">#AxisInt[0] = lu.f_Matrix_transpose(lu.f_Matrix_dot(mRot,lu.f_Matrix_transpose([AxisInt[0]])))[0]</span>
        <span class="c">#AxisInt[1] = lu.f_Matrix_transpose(lu.f_Matrix_dot(mRot,lu.f_Matrix_transpose([AxisInt[1]])))[0]</span>
        <span class="n">AxisIntNew0</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">mRot</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">AxisIntNew1</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span><span class="s">&quot;+&quot;</span><span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">mRot</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">AxisInt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">AxisIntNew0</span>
        <span class="n">AxisInt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">AxisIntNew1</span>
        <span class="c">#print(AxisInt)</span>

        
        <span class="c">#Create cartesian axis</span>
        <span class="n">OriginalVector</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
        <span class="c">#OriginalVector = self.PrimitiveCellVector</span>
        <span class="n">listVector</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">aAxis</span> <span class="ow">in</span> <span class="n">AxisInt</span><span class="p">:</span>
            <span class="n">Vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">Vector</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">aAxis</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">OriginalVector</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">listVector</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Vector</span><span class="p">)</span>
        
        <span class="c">#print(OriginalVector)</span>
        <span class="c">#print(listVector)</span>
        
        <span class="c">#Get possible cell enlarge times to slice a supercell from it</span>
        <span class="c">#Detect 8 vertex of the supercell</span>
        <span class="c">#nMax = 1</span>
        <span class="n">listVertex</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">a1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">a2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">a3</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                    <span class="n">list_a</span> <span class="o">=</span> <span class="p">[[</span><span class="n">a1</span><span class="p">],[</span><span class="n">a2</span><span class="p">],[</span><span class="n">a3</span><span class="p">]]</span>
                    <span class="n">listVertex</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">AxisInt</span><span class="p">),</span><span class="n">list_a</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">print</span><span class="p">(</span><span class="n">listVertex</span><span class="p">)</span>
        <span class="n">arMax</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">aVertex</span> <span class="ow">in</span> <span class="n">listVertex</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">aVertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">arMax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]):</span>
                    <span class="n">arMax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">aVertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="p">(</span> <span class="n">aVertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">arMax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="n">arMax</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">aVertex</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    
        <span class="n">arMax</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arMax</span><span class="p">]</span>

        <span class="c">#print(listVertex)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">arMax</span><span class="p">)</span>
        
        <span class="n">listAtom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GetAtomList</span><span class="p">(</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="s">&quot;conv&quot;</span><span class="p">,</span><span class="n">arMax</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">listAtom</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">listAtom</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">result</span><span class="o">.</span><span class="n">ReadFromPrimitiveCellVector</span><span class="p">(</span><span class="n">listVector</span><span class="p">,</span> <span class="mi">14</span><span class="p">)</span>
        <span class="c">#convert all lattice under non-standard vectors to primitive coords ( always standards )</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="n">listAtom</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">listAtom</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">listVector</span><span class="p">))</span> <span class="p">,</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">([</span><span class="n">aAtom</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]])))[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c">#print(result.listAtom[-1])</span>
            <span class="n">result</span><span class="o">.</span><span class="n">CheckAtom</span><span class="p">()</span>
        <span class="c">#self.AddAtom([ [x[0]] + lu.f_Matrix_transpose(lu.f_Matrix_dot(mRot,lu.f_Matrix_transpose([x[1:4]])))[0] for x in listAtom] , &quot;bohr&quot;, &quot;conv&quot;)</span>
              
        <span class="c">#print(result.listAtom)</span>
        <span class="k">return</span> <span class="n">result</span>
            </div>
<div class="viewcode-block" id="Lattice.CheckAtom"><a class="viewcode-back" href="../main_struct.html#common_caseutil.Lattice.CheckAtom">[docs]</a>    <span class="k">def</span> <span class="nf">CheckAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Check whether an Atom is &lt; 0 or &gt; 1, or there are duplicated atoms</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c">#remove precision problem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CorrectError</span><span class="p">()</span>
        <span class="c"># check 0 &lt; x &lt; 1</span>
        <span class="k">for</span> <span class="n">aAtom</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="p">):</span>
                    <span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="p">(</span> <span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">):</span>
                    <span class="n">aAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c">#check duplicate</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="p">(</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">)):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">while</span> <span class="p">(</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">)):</span>
                <span class="n">aAtom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">aAtomRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">bSame</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="n">aAtomRef</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">aAtom</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">Lattice</span><span class="o">.</span><span class="n">dErrMax</span><span class="p">):</span>
                        <span class="n">bSame</span> <span class="o">=</span> <span class="bp">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">bSame</span><span class="p">):</span>
                    <span class="c">#print(&quot;%d atom is duplicated with %d&quot; % (j,i))</span>
                    <span class="c">#print(aAtom,aAtomRef)</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">listAtom</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>       
                </div></div>
<div class="viewcode-block" id="f_GetReciprocalLattice"><a class="viewcode-back" href="../main_struct.html#common_caseutil.f_GetReciprocalLattice">[docs]</a><span class="k">def</span> <span class="nf">f_GetReciprocalLattice</span><span class="p">(</span><span class="n">matR</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get reciprocal lattice vectors from real lattice  or vice versa</span>
<span class="sd">    Recprocal lattice is just inversion of real lattice * 2\pi, indeed.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">matK</span> <span class="o">=</span>  <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_Op_Scalar</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">matR</span><span class="p">)),</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">matK</span>
    

</div>
<div class="viewcode-block" id="KPointsT"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT">[docs]</a><span class="k">class</span> <span class="nc">KPointsT</span><span class="p">():</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Represent a set of kpoints</span>
<span class="sd">    Contains k-point coordinate, k-point name</span>
<span class="sd">    &#39;&#39;&#39;</span>

<span class="c">#format enum</span>
    <span class="n">format_xyz</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">format_xyzn</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">format_xyzw</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">format_xyzwn</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">format_nxyz</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">format_nxyzw</span> <span class="o">=</span> <span class="mi">6</span>

<span class="c">#Dictionary to create k-points list from specified number of high-symmetryk-points</span>
<span class="c">#All lines between k-points are connected, but for 4,6,8, one duplicate path is choosed as it is impossible to draw all lines in one stroke !</span>
    <span class="n">dicOneLine</span> <span class="o">=</span> <span class="p">{</span>
            <span class="mi">2</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
            <span class="mi">3</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
            <span class="mi">4</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span>
            <span class="mi">5</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
            <span class="mi">6</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span>
            <span class="mi">7</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span>
            <span class="mi">8</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">6</span><span class="p">)</span>
            <span class="p">}</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFile</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="o">=</span> <span class="p">[]</span> <span class="c">#The k-point list. Format: name,x,y,z,weight ( x,y,z maybe crystal, cartesian, tpiba )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">=</span> <span class="s">&quot;crystal&quot;</span> <span class="c"># The k-point mode. Possible value include cartesian(cart), crystal, tpiba, tpibabc. Note, cartesian coordination are in unit bohr or bohr^{-1}. &quot;ang&quot; and &quot;bohr&quot; means Cartesian, but in given unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">latt</span> <span class="o">=</span> <span class="bp">None</span> <span class="c">#The structure corresponding to this k-point list,used to convert in 2pi/a unit and crystal unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kFormat</span> <span class="o">=</span> <span class="n">KPointsT</span><span class="o">.</span><span class="n">format_xyz</span> <span class="c">#default k-points format to read</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">stFile</span> <span class="o">!=</span> <span class="bp">None</span> <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ReadFromFile</span><span class="p">(</span><span class="n">stFile</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__ReFormat__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">kpt</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        make kpt format as namekx,ky,kz,weight</span>

<span class="sd">        Acceptable k-point format ( &quot;,&quot; means space or tab )</span>
<span class="sd">           [name],kx,ky,kz,[weight]</span>
<span class="sd">        or kx,ky,kz,[name]</span>
<span class="sd">        or kx,ky,kz,weight,[name]</span>
<span class="sd">        </span>
<span class="sd">        All element can be either string or float</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpt</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Unexpected data format in k-point file&quot;</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">kpt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">):</span> <span class="c">#must be 3 digit</span>
            <span class="k">return</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kpt</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># detect does any value start with character</span>
            <span class="n">listNum</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">listString</span> <span class="o">=</span> <span class="p">[]</span> 
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">kpt</span><span class="p">)):</span>
                <span class="k">if</span> <span class="p">(</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kpt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kpt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&quot;-&quot;</span><span class="p">):</span>
                    <span class="n">listString</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">listNum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="n">listString</span> <span class="o">=</span> <span class="n">listString</span> <span class="o">+</span> <span class="n">listNum</span>

            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listString</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span> <span class="p">):</span> 
                <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listNum</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                    <span class="c"># if there is not weight, add it</span>
                    <span class="n">listString</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c"># there is no name, add it</span>
                    <span class="n">listString</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">listString</span>


            <span class="k">return</span> <span class="n">listString</span>

<div class="viewcode-block" id="KPointsT.CreateFromPointLine"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.CreateFromPointLine">[docs]</a>    <span class="k">def</span> <span class="nf">CreateFromPointLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">listK2</span><span class="p">,</span><span class="n">listPointsCount</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">nTotal</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">mLatt</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">nDivisor</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read k-point from x,y,z + point along the line format</span>
<span class="sd">        kpt must be in formar [x,y,z], [x,y,z,name] or [name,x,y,z]</span>
<span class="sd">        The mode is not changed during this process</span>

<span class="sd">        :param listK2: the list of k-points in KPointsT readable format</span>
<span class="sd">        :param listPointsCount: the number of points along each line</span>
<span class="sd">        :param nTotal: the total number of points. The lattice must be specified if use this option, and k-points will be spread homogeneously along lines</span>
<span class="sd">        :param mLatt: the lattice vectors for k-points, necessary if k-points is in internal coordinate</span>
<span class="sd">        :param nDivisor: if this number is set, then number of points along each line must be a divisor/factor of this number. This function is especially useful for WIEN2k. Set to 0 means the program will automatically choose a number.</span>
<span class="sd">        :return: the divisor</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">FindNear</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">ar</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Find nearest number of x in list y ( y in ascending order )</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ar</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">):</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">y</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">*</span><span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                            <span class="k">return</span> <span class="n">ar</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">y</span>
            <span class="k">return</span> <span class="n">ar</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c">#return final one if not found</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">listK</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">__ReFormat__</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">listK2</span><span class="p">]</span>

<span class="c">#Use or create number of points along each lines</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">listPointsCount</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nTotal</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Must specify number of k-points along each lines or the total number of k-points&quot;</span>
            <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">!=</span> <span class="s">&quot;cart&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">!=</span> <span class="s">&quot;cartesian&quot;</span> <span class="ow">and</span> <span class="n">mLatt</span>  <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Must specify lattice vectors when create k-points list from internal coordinate&quot;</span>
<span class="c">#Create ca</span>
            <span class="n">stModeOld</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span>
<span class="c">#Use self as temp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">listK</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ConvertUnit</span><span class="p">(</span><span class="s">&quot;cart&quot;</span><span class="p">,</span><span class="n">mLatt</span><span class="p">)</span> 
<span class="c">#Calculate distance</span>
            <span class="n">listDist</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listK2</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">listDist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])))</span>
<span class="c">#Calculate number of k-points</span>
            <span class="n">dDist</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">listDist</span><span class="p">)</span>
            <span class="n">listPointsCount</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span> <span class="p">(</span><span class="n">nTotal</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span> <span class="o">/</span> <span class="n">dDist</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">listDist</span><span class="p">]</span>
<span class="c">#Restore self</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">=</span> <span class="n">stModeOld</span>

<span class="c">#Modify number of k-points to fit divisor. Note the difference between k-points coordinate must be considered too</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">nDivisor</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">):</span>
            <span class="n">nDivisorOld</span> <span class="o">=</span> <span class="n">nDivisor</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nDivisor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">nDivisor</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="mi">3</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="mi">5</span><span class="o">**</span><span class="mi">2</span> <span class="c"># The guess value for most possible </span>
            <span class="n">listPointsCount2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">nCount</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">listPointsCount</span><span class="p">):</span>
<span class="c">#Calculate fractional coordinate in output unit</span>
                <span class="n">vDiff</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">listK</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="n">listK</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>
<span class="c">#Get n/m fractional representaion</span>
                <span class="n">vDiff</span> <span class="o">=</span> <span class="p">[</span> <span class="n">f_FindFraction</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vDiff</span> <span class="p">]</span>

<span class="c">#Check the divisor for each dimension</span>
                <span class="k">for</span> <span class="n">n1</span><span class="p">,</span><span class="n">n2</span> <span class="ow">in</span> <span class="n">vDiff</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span> <span class="n">nDivisor</span> <span class="o">%</span> <span class="n">n2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
                        <span class="n">n3</span> <span class="o">=</span> <span class="n">nDivisor</span>
                        <span class="n">nDivisor</span> <span class="o">=</span> <span class="n">f_FindLCM</span><span class="p">(</span><span class="n">nDivisor</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span>
                        <span class="k">print</span><span class="p">(</span><span class="s">&quot;</span><span class="si">%i</span><span class="s"> is not divided by k-points coordinate, increased to </span><span class="si">%i</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span> <span class="n">n3</span><span class="p">,</span><span class="n">nDivisor</span><span class="p">))</span>
<span class="c">#Find the GCD for divisor for 3-D fractional</span>
                <span class="n">n3</span> <span class="o">=</span> <span class="n">f_FindGCD</span><span class="p">(</span><span class="n">nDivisor</span><span class="o">/</span><span class="n">vDiff</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">f_FindGCD</span><span class="p">(</span><span class="n">nDivisor</span><span class="o">/</span><span class="n">vDiff</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="n">nDivisor</span><span class="o">/</span><span class="n">vDiff</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>

<span class="c">#Calculate all divisor</span>
                <span class="n">listDivisor</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">n3</span><span class="o">/</span><span class="n">x</span><span class="o">*</span><span class="n">x</span><span class="o">==</span><span class="n">n3</span><span class="p">,</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n3</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">listPointsCount2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">FindNear</span><span class="p">(</span><span class="n">listPointsCount</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">listDivisor</span><span class="p">))</span>
            <span class="c">#Search for one line end</span>

            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Number of k-points is modified to </span><span class="si">%i</span><span class="s"> according to idv&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">listPointsCount2</span><span class="p">)</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">listPointsCount2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Equal distance distribution:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">listPointsCount</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Current distribution:&quot;</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">listPointsCount2</span><span class="p">)</span>
            <span class="n">listPointsCount</span> <span class="o">=</span> <span class="n">listPointsCount2</span>
            

        <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">listK</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">listPointsCount</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s">&quot;Error: Number of k-points must be number of lines + 1&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">listPointsCount</span><span class="p">)):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">listPointsCount</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listK</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
                <span class="n">kpt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">listK</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="o">*</span><span class="p">(</span><span class="n">l</span><span class="o">-</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="n">l</span><span class="p">),</span><span class="s">&quot;+&quot;</span><span class="p">,</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_Scalar</span><span class="p">(</span><span class="n">listK</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="mf">1.0</span><span class="o">*</span><span class="n">j</span><span class="o">/</span><span class="n">l</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ReFormat__</span><span class="p">(</span><span class="n">kpt</span><span class="p">))</span>

        <span class="c">#add the last value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">listK</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">nDivisor</span>
</div>
<div class="viewcode-block" id="KPointsT.CreateKPointsFromSymmetry"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.CreateKPointsFromSymmetry">[docs]</a>    <span class="k">def</span> <span class="nf">CreateKPointsFromSymmetry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">nGroup</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create high-symmetry k-points list from spacegroup symmetry</span>
<span class="sd">        The lattice must be set before invoke this function</span>

<span class="sd">        :param nGroup: the 230 space group index (1-230)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">def</span> <span class="nf">ParseDiv</span><span class="p">(</span><span class="n">st</span><span class="p">):</span>
            <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">            Return numerical for &quot;n/m&quot;</span>
<span class="sd">            &#39;&#39;&#39;</span>
            <span class="n">list1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;/&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">list1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">list1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">list1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">st</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;Lattice must be specified before create k-points in band structure&quot;</span>
        <span class="n">listSpec</span> <span class="o">=</span> <span class="bp">None</span>
<span class="c">#Detect UAC : whether this space group have A / C axis variants depending on the angles</span>
        <span class="n">bHasUAC</span> <span class="o">=</span> <span class="n">kpt_spec</span><span class="o">.</span><span class="n">listSpaceGroupKPointsUAC</span><span class="p">[</span><span class="n">nGroup</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">None</span>
        <span class="n">nUAC</span> <span class="o">=</span> <span class="mi">0</span>
<span class="c">#Get k-points set</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bHasUAC</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">):</span>
                <span class="n">nUAC</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">fLatticeAngle</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">90</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.01</span><span class="p">):</span>
                <span class="n">nUAC</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nUAC</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">nUAC</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;The cell shape is not consistent with space group&quot;</span>
<span class="c">#Unique axis C</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">nUAC</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">listSpec</span> <span class="o">=</span> <span class="n">kpt_spec</span><span class="o">.</span><span class="n">listSpaceGroupKPointsUAC</span><span class="p">[</span><span class="n">nGroup</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="p">(</span> <span class="n">listSpec</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
<span class="c">#For non-UAC cases, it is possible to find multiple k-points definition due to different a,b,c relationship</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">fLatticeLength</span>
            <span class="k">for</span> <span class="n">kpt_cond</span> <span class="ow">in</span> <span class="n">kpt_spec</span><span class="o">.</span><span class="n">listSpaceGroupKPoints</span><span class="p">[</span><span class="n">nGroup</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">kpt_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">)):</span>
                    <span class="n">listSpec</span> <span class="o">=</span> <span class="n">kpt_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">listSpec</span> <span class="o">==</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">,</span><span class="s">&quot;The cell shape is not consistent with space group&quot;</span>

        <span class="c">#Parse k-points data</span>
        <span class="c">#Always use primitive cell</span>
        <span class="n">listK</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="n">ParseDiv</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">listSpec</span><span class="p">]</span>
<span class="c">#Try to add line for each two k-points</span>
        <span class="n">listK2</span> <span class="o">=</span> <span class="p">[</span> <span class="n">listK</span><span class="p">[</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">KPointsT</span><span class="o">.</span><span class="n">dicOneLine</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">listK</span><span class="p">)]]</span>

        <span class="c">#print(listK2)</span>
        <span class="k">return</span> <span class="n">listK2</span>
        <span class="c">#self.CreateFromPointLine(listK2,nTotal=nTotal,mLatt=self.latt.PrimitiveCellVector)</span>
     </div>
<div class="viewcode-block" id="KPointsT.ReadFromList"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.ReadFromList">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFromList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">list_kp</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Create object from simple k-point list in format </span>
<span class="sd">        [ [x1,y1,z1] ...]</span>
<span class="sd">        or </span>
<span class="sd">        [ [x1,y1,z1,w1] ...]</span>
<span class="sd">        or</span>
<span class="sd">        [ [name,x1,y1,z1,w1] ...]</span>
<span class="sd">        The unit is not concerned in this case</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n_item</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_kp</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n_item</span> <span class="o">==</span> <span class="mi">3</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_kp</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n_item</span> <span class="o">==</span> <span class="mi">4</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="p">[</span> <span class="p">[</span><span class="s">&quot;&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">list_kp</span><span class="p">]</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">n_item</span> <span class="o">==</span> <span class="mi">5</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span> <span class="o">=</span> <span class="n">list_kp</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s">&quot;Unknown format&quot;</span><span class="p">)</span>
</div>
<div class="viewcode-block" id="KPointsT.ReadFromFile"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.ReadFromFile">[docs]</a>    <span class="k">def</span> <span class="nf">ReadFromFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read k-point from a file in raw format</span>
<span class="sd">        format as first line is k-point data mode; if it is not &quot;crystal&quot;/&quot;cartesian&quot;/&quot;tpiba&quot;/&quot;piba&quot;, then it is set to crystal and this line is used as k-point</span>
<span class="sd">        each k-point format ( &quot;,&quot; means space or tab )</span>
<span class="sd">        * [name],kx,ky,kz,[weight]</span>
<span class="sd">        * kx,ky,kz,[name]</span>
<span class="sd">        * kx,ky,kz,weight,[name]</span>
<span class="sd">        name must start with character and no space in it; if it start with number, then it is treated as kx!</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;r&#39;</span><span class="p">)</span>
        
        <span class="n">stLine</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">ar_stLine</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span> <span class="ow">not</span> <span class="n">stLine</span> <span class="ow">in</span> <span class="p">(</span><span class="s">&quot;crystal&quot;</span><span class="p">,</span><span class="s">&quot;tpiba&quot;</span><span class="p">,</span><span class="s">&quot;cartesian&quot;</span><span class="p">)):</span><span class="c">#Not a format data</span>
            <span class="n">ar_stLine</span> <span class="o">=</span> <span class="p">[</span><span class="n">stLine</span><span class="p">]</span> <span class="o">+</span> <span class="n">ar_stLine</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">=</span> <span class="n">stLine</span>

        <span class="k">for</span> <span class="n">stLine</span> <span class="ow">in</span> <span class="n">ar_stLine</span><span class="p">:</span>
            <span class="n">arLine</span>  <span class="o">=</span> <span class="n">stLine</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">arLine</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">):</span> <span class="c">#Empty line</span>
                <span class="k">continue</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__ReFormat__</span><span class="p">(</span><span class="n">arLine</span><span class="p">))</span>
        <span class="k">pass</span>
</div>
<div class="viewcode-block" id="KPointsT.WriteToFile"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.WriteToFile">[docs]</a>    <span class="k">def</span> <span class="nf">WriteToFile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stFileName</span><span class="p">,</span><span class="n">bWriteName</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">bWriteWeight</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Write k-point list to a file with/without</span>

<span class="sd">        :param bUseName: write name or not, default no</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">stFileName</span><span class="p">,</span><span class="s">&#39;w&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span> <span class="n">bWriteName</span> <span class="p">):</span>
            <span class="k">for</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;</span><span class="si">%10s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="p">[</span><span class="s">&quot;</span><span class="si">%12.7f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">&quot;</span><span class="si">%12.7f</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s">&#39;</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
   </div>
<div class="viewcode-block" id="KPointsT.GetTurningPoint"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.GetTurningPoint">[docs]</a>    <span class="k">def</span> <span class="nf">GetTurningPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return index of turning points in the k-point path</span>
<span class="sd">        Start point and end point are not included</span>
<span class="sd">        Index start from 0</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">list_turnpt</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">dAngle</span><span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_angle3</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]),</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]))</span>
            <span class="k">if</span> <span class="p">(</span> <span class="n">dAngle</span> <span class="o">&gt;</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">list_turnpt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">list_turnpt</span>

</div>
<div class="viewcode-block" id="KPointsT.ConvertUnit"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.ConvertUnit">[docs]</a>    <span class="k">def</span> <span class="nf">ConvertUnit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">stModeNew</span><span class="p">,</span><span class="n">mLatt</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Convert k-points coordinate between crystal,cartesian and tpiba unit based on structure</span>
<span class="sd">        Note this conversion mostly only appeared in orthogonal lattice, as in practice, non-orthogonal lattice never use tpiba unit.</span>
<span class="sd">        Equation : matLattVec . vecCrystal = vecCartesian</span>

<span class="sd">        :param stModeNew: the new k-point unit</span>
<span class="sd">        :param mLatt: the real-space lattice vector that k-point is based on; note for some program it is primitive lattice ( like VASP and YAehmop ), and others are conventional lattice (Wien2K cubic). If None is used, we use conventional lattice for tpiabc (which belongs to Wien2K cubic) and primitive for others. </span>
<span class="sd">        :return: whether the conversion completed</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="kn">from</span> <span class="nn">constants</span> <span class="kn">import</span> <span class="n">Ang2Bohr</span>
        <span class="c">#Run even if two modes are same to verify its </span>
        <span class="c">#if ( stModeNew == self.stMode):</span>
        <span class="c">#    return</span>

        <span class="c">#Just * or / if ang -&gt; bohr and bohr -&gt; ang</span>
<span class="c">#Note this is reciprocal lattice so reveresed</span>
        <span class="n">dScale</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">stModeNew</span> <span class="o">==</span> <span class="s">&quot;ang&quot;</span><span class="p">):</span>
            <span class="n">dScale</span> <span class="o">*=</span> <span class="n">Ang2Bohr</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">==</span> <span class="s">&quot;ang&quot;</span><span class="p">):</span>
            <span class="n">dScale</span> <span class="o">/=</span> <span class="n">Ang2Bohr</span>

        <span class="n">b_auto</span> <span class="o">=</span> <span class="n">mLatt</span> <span class="ow">is</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b_auto</span><span class="p">):</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">latt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">):</span>
                <span class="k">print</span><span class="p">(</span><span class="s">&quot;Unable to convert k-point unit as lattice information unavailable.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">==</span> <span class="s">&quot;tpibabc&quot;</span><span class="p">):</span>
                <span class="n">mLatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mLatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">PrimitiveCellVector</span>
<span class="c">#tpiba unit</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;tpiba&quot;</span><span class="p">,</span><span class="s">&quot;tpibabc&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="n">stModeNew</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;tpiba&quot;</span><span class="p">,</span><span class="s">&quot;tpibabc&quot;</span><span class="p">]):</span>
            <span class="n">mLattConv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
            <span class="n">listUnit</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">mLattConv</span> <span class="p">]</span>
            <span class="n">dTpibaUnit</span> <span class="o">=</span> <span class="n">listUnit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c">#       dTpibaUnit = 2*math.pi/lu.f_List_norm3(mLattConv[0])</span>
<span class="c">#       listUnit = [dTpibaUnit,2*math.pi/lu.f_List_norm3(mLattConv[1]), 2*math.pi/lu.f_List_norm3(mLattConv[2])]</span>
<span class="c">#       print(listUnit)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;crystal&quot;</span><span class="p">,</span><span class="s">&quot;cart&quot;</span><span class="p">,</span><span class="s">&quot;cartesian&quot;</span><span class="p">,</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="s">&quot;ang&quot;</span><span class="p">]</span>  <span class="ow">or</span> <span class="n">stModeNew</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&quot;crystal&quot;</span><span class="p">,</span><span class="s">&quot;cart&quot;</span><span class="p">,</span><span class="s">&quot;cartesian&quot;</span><span class="p">,</span><span class="s">&quot;bohr&quot;</span><span class="p">,</span><span class="s">&quot;ang&quot;</span><span class="p">]</span> <span class="p">):</span>
            <span class="n">matR</span> <span class="o">=</span> <span class="n">f_GetReciprocalLattice</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">mLatt</span><span class="p">))</span>
            <span class="n">matRi</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">matR</span><span class="p">)</span>
<span class="c">#           print(&quot;matR&quot;,matR)</span>
<span class="c">#           print(&quot;matRi&quot;,matRi)</span>

        <span class="c">#Convert current k-point in any unit to cartesian</span>
        <span class="n">mKPt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">kpt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">:</span>
            <span class="n">mKPt</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>

        <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">mKPt</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">==</span> <span class="s">&quot;crystal&quot;</span><span class="p">):</span>
            <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">matR</span><span class="p">,</span><span class="n">mKPt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">==</span> <span class="s">&quot;tpiba&quot;</span><span class="p">):</span>
            <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_Op_Scalar</span><span class="p">(</span><span class="n">mKPt</span><span class="p">,</span><span class="s">&quot;*&quot;</span><span class="p">,</span><span class="n">dTpibaUnit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">==</span> <span class="s">&quot;tpibabc&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mKPt</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">mKPt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="n">listUnit</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

        <span class="c">#Convert cartesian to any unit</span>

        <span class="c">#Recontruct lattice</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b_auto</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">stModeNew</span> <span class="o">==</span> <span class="s">&quot;tpibabc&quot;</span><span class="p">):</span>
                <span class="n">mLatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">ConventionalCellVector</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mLatt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">latt</span><span class="o">.</span><span class="n">PrimitiveCellVector</span>
            <span class="n">matR</span> <span class="o">=</span> <span class="n">f_GetReciprocalLattice</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">mLatt</span><span class="p">))</span>
            <span class="n">matRi</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_inv3</span><span class="p">(</span><span class="n">matR</span><span class="p">)</span>
            <span class="n">dTpibaUnit</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">mLatt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">listUnit</span> <span class="o">=</span> <span class="p">[</span><span class="n">dTpibaUnit</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">mLatt</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm3</span><span class="p">(</span><span class="n">mLatt</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span>
<span class="c">#           print(&quot;matR&quot;,matR)</span>
<span class="c">#           print(&quot;matRi&quot;,matRi)</span>

        <span class="k">if</span> <span class="p">(</span> <span class="n">stModeNew</span> <span class="o">==</span> <span class="s">&quot;tpiba&quot;</span> <span class="p">):</span>
            <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_Op_Scalar</span><span class="p">(</span><span class="n">matR</span><span class="p">,</span><span class="s">&quot;/&quot;</span><span class="p">,</span><span class="n">dTpibaUnit</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">stModeNew</span> <span class="o">==</span> <span class="s">&quot;crystal&quot;</span><span class="p">):</span>
            <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_dot</span><span class="p">(</span><span class="n">matRi</span><span class="p">,</span><span class="n">mKPt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="p">(</span> <span class="n">stModeNew</span> <span class="o">==</span> <span class="s">&quot;tpibabc&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">mKPt</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">mKPt</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/=</span> <span class="n">listUnit</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>


        <span class="n">mKPt</span> <span class="o">=</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_Matrix_transpose</span><span class="p">(</span><span class="n">mKPt</span><span class="p">)</span>

<span class="c">#Convert ang / bohr</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mKPt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">*</span><span class="n">dScale</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kpt</span><span class="p">]</span>


        <span class="bp">self</span><span class="o">.</span><span class="n">stMode</span> <span class="o">=</span> <span class="n">stModeNew</span>
        <span class="k">return</span> <span class="bp">True</span>
</div>
<div class="viewcode-block" id="KPointsT.get_k_xaxis"><a class="viewcode-back" href="../main_struct.html#common_caseutil.KPointsT.get_k_xaxis">[docs]</a>    <span class="k">def</span> <span class="nf">get_k_xaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get a list of points on one axis for band structure plotting</span>

<span class="sd">        :return:list_x and list_name for x-axis and k-point names</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">list_name</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">list_dist</span> <span class="o">=</span> <span class="p">[]</span> <span class="c">#x-axis in plot rely on k-k distance</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">kpt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">list_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">list_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">list_dist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">lu</span><span class="o">.</span><span class="n">f_List_norm</span><span class="p">(</span><span class="n">lu</span><span class="o">.</span><span class="n">f_List_Op_List</span><span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">],</span><span class="s">&quot;-&quot;</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">listKPt</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">])))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">kpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s">&quot;&quot;</span><span class="p">):</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">kpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">&#39;</span> <span class="p">):</span> <span class="c">#delete first backslash as neither gnuplot nor xmgrace use it. SIESTA use &quot;\&quot; for Latex. </span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="n">list_name</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">name</span><span class="p">,</span><span class="n">list_dist</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">list_dist</span><span class="p">,</span> <span class="n">list_name</span>
      </div></div>
</pre></div>

          </div>
        </div>
      </div>
        </div>
        <div class="sidebar">
          <h3>Table Of Contents</h3>
          <ul>
<li class="toctree-l1"><a class="reference internal" href="../bandstructure.html">Band structure post-processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../dos.html">Density of States post-processing</a></li>
</ul>

          <div role="search">
            <h3 style="margin-top: 1.5em;">Search</h3>
            <form class="search" action="../search.html" method="get">
                <input type="text" name="q" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
            </form>
            <p class="searchtip" style="font-size: 90%">
                Enter search terms or a module, class or function name.
            </p>
          </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

    <div class="footer-wrapper">
      <div class="footer">
        <div class="left">
          <div role="navigation" aria-label="related navigaton">
            <a href="../py-modindex.html" title="Python Module Index"
              >modules</a> |
            <a href="../genindex.html" title="General Index"
              >index</a>
          </div>
          <div role="note" aria-label="source link">
          </div>
        </div>

        <div class="right">
          
    <div class="footer" role="contentinfo">
        &copy; Copyright 2014, TMC group.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.1.
    </div>
        </div>
        <div class="clearer"></div>
      </div>
    </div>

  </body>
</html>