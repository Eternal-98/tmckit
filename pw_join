#!/usr/bin/env python
#!This scripts can join case.x_proc to one file
#Now only x=almblm supported
import os,sys
from subprocess import check_output
from argparse import ArgumentParser

parser = ArgumentParser(description="Join all files generated by parallel WIEN2k to the serial format, which allows one to execute serial command later.")
parser.add_argument('filename',type=str,default="almblm",nargs="?",help="The file suffix to be joined, numbers not included. Currently only 'almblm' is supported.")
args = parser.parse_args()

suffix=args.filename

def assign_substring(s,i1,i2,s2):
    if (len(s2) != i2-i1):
        raise ValueError("The new string is not the same length: \"%s\"" % s2)
    return s[:i1] + s2 + s[i2:]

print("Joining all .%s_x files..." % suffix)
casename = os.path.basename(os.getcwd())

if (suffix == "almblm"):
#Read the Fermi level 
#The 4th line in .almblm_* is wrong in parallel
    eig_fermi = float([x for x in check_output(["grep",":FER",casename+".output2"]).split("\n") if x != ""][-1].split()[-1])
    print("  Fermi level from output2: %f" % eig_fermi)


#Get list of almblm files
    filename_ab = casename + ".almblm_"
    t = len(filename_ab)

    list_proc = []
    for dir, dirnames, filenames in os.walk(os.getcwd()):
        for filename in filenames:
            if (filename.startswith(filename_ab)):
                list_proc.append(int(filename[t:]))
        break

    nproc = max(list_proc)
    nproc2 = len(list_proc)
    if (nproc2 != nproc):
        raise ValueError("Not enough .almblm_x files: %i/%i." % (nproc,nproc2)  )

#Read
    head = []
    ik = 0
    head_atom = []
    val = []
    for n in xrange(1,nproc+1):
        filename2 = filename_ab+str(n)
        print("  Reading %s..." % filename2)
        f = open(filename2,'r')
        lines = f.readlines()
        f.close()

#Read head
        head = lines[:4]
        nk2 = int(head[1])
        head[1] = "%12i\n" % (ik+nk2)
        head[3] = "%19.14f\n" % eig_fermi
#Read head of an atom
        i1 = 7
        i2 = 18
#Read values
        ik2 = 0
        iatom = -1
        i = 4
        b_real = True
        while (i < len(lines)):
#Head of atom ? or just a k point
            if (not "IK" in lines[i]):
                for j in xrange(i,len(lines)):
                    if ("IK" in lines[j]):
                        break
#Add dummy if the first time
                iatom += 1
                if (len(head_atom) == iatom):
                    head_atom.append([])
                    val.append([])
                head_atom[iatom] = lines[i:j]
                i = j
#Parse No. of the k-point and
            ik_val = int(lines[i][i1:i2])
            lines[i] = assign_substring(lines[i],i1,i2,("%" +str(i2-i1)+ "i") % (ik_val+ik)) 
            ik2 += 1

#Read almblmclm values
            val1 = val[iatom]
            val1.append(lines[i])
            i += 1
#End if no more brackets but dot
            b_real = True 
            while (i < len(lines) and  ("(" in lines[i] or (not "." in lines[i] and not "IK" in lines[i]) or b_real)):
                val1.append(lines[i])
                if ("(" in lines[i]):
                    b_real = False
                i += 1
            val[iatom] = val1

        ik += nk2

#Write
    filename2 = casename + ".almblm"
    print("  Writing %s ..." % filename2)
    f = open(filename2,'w')
    for line in head:
        f.write(line)
    for head1,val1 in zip(head_atom,val):
        for line in head1:
            f.write(line)
        for line in val1:
            f.write(line)
    f.close()
else:
    print("%s has not been implemented yet.")
